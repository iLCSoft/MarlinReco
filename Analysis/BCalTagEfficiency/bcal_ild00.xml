<?xml version="1.0" encoding="us-ascii"?>
<!-- ?xml-stylesheet type="text/xsl" href="http://ilcsoft.desy.de/marlin/marlin.xsl"? -->
<!-- ?xml-stylesheet type="text/xsl" href="marlin.xsl"? -->

<!-- Loading shared library : /afs/desy.de/group/it/ilcsoft/v01-03-06/LCFIVertex/v00-02-07-dev/lib/libLCFIVertex.so -->
<!-- Loading shared library : /afs/desy.de/group/it/ilcsoft/v01-03-06/MarlinReco/v00-10-04/lib/libMarlinReco.so -->
<!-- Loading shared library : /afs/desy.de/group/it/ilcsoft/v01-03-06/PandoraPFA/v02-02-02/lib/libPandoraPFA.so -->
<!-- Loading shared library : /afs/desy.de/group/it/ilcsoft/v01-03-06/SiliconDigi/v00-04-01/lib/libSiliconDigi.so -->
<!-- Loading shared library : /afs/desy.de/group/it/ilcsoft/v01-03-06/MarlinTPC/v00-02-06/lib/libMarlinTPC.so -->
<!-- Loading shared library : /afs/desy.de/group/it/ilcsoft/v01-03-06/CEDViewer/v00-05/lib/libCEDViewer.so -->
<!-- Loading shared library : /afs/desy.de/group/it/ilcsoft/v01-03-06/Overlay/v00-02/lib/libOverlay.so -->
<!-- Loading shared library : /afs/desy.de/group/it/ilcsoft/v01-03-06/Eutelescope/v00-00-06/lib/libEutelescope.so -->
<!--##########################################
    #                                        #
    #     Example steering file for marlin   #
    #                                        #
    ##########################################-->


<marlin xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://ilcsoft.desy.de/marlin/marlin.xsd">
 <execute>
  <!--processor name="MyAIDAProcessor"/-->
  <processor name="MyBCalTagEfficiency"/>
  <!--processor name="Check"/-->  
  <processor name="MyLCIOOutputProcessor"/>  
 </execute>

 <global>
  <!--parameter name="LCIOInputFiles">/afs/desy.de/user/m/montull/flc/MarlinWorkdir/data/DST01-04_ppr002_aa_cc_w12174_500_LDCPrime_02Sc_LCP_ep+0.0_em+0.0_Slac_SM_0002.slcio </parameter-->
  <parameter name="LCIOInputFiles">/data/boehmej/flc/susy/data/DST01-06_ppr004_aa_cc_w12174_500_ILD_00_LCP_ep+0.0_em+0.0_Slac_SM_0001.slcio </parameter>
  <!-- limit the number of processed records (run+evt): -->  
  <parameter name="MaxRecordNumber" value="0" />  
  <parameter name="SkipNEvents" value="0" />  
  <parameter name="SupressCheck" value="false" />  
  <parameter name="GearXMLFile"> gear_ILD_00.xml </parameter>  
  <parameter name="Verbosity" options="DEBUG0-4,MESSAGE0-4,WARNING0-4,ERROR0-4,SILENT"> DEBUG0  </parameter> 
 </global>

 <processor name="MyAIDAProcessor" type="AIDAProcessor">
 <!--Processor that handles AIDA files. Creates on directory per processor.  Processors only need to create and fill the histograms, clouds and tuples. Needs to be the first ActiveProcessor-->
  <!-- compression of output file 0: false >0: true (default) -->
  <parameter name="Compress" type="int">1 </parameter>
  <!-- filename without extension-->
  <parameter name="FileName" type="string">fwdveto </parameter>
  <!-- type of output file xml (default) or root ( only OpenScientist)-->
  <parameter name="FileType" type="string">root </parameter>
</processor>

<processor name="MyBCalTagEfficiency" type="BCalTagEfficiency"> 
<!--Simple processor to test the marlin application. Prints run and event number.-->  
<parameter name="CollectionName" type="string" lcioInType="MCParticle">MCParticlesSkimmed </parameter> 
<!--Name of the output collection for BCAL particles -->  
<parameter name="OuputCollectionName" type="string" lcioOutType="ReconstructedParticle">BCALParticles</parameter>  
<!--Name of input file for background energy density-->
<parameter name="BackgroundFilename" type="string">bg_aver_LDC_4T_14mrad_AntiDID.root</parameter>
<!--position of the BeamCal front face , can this be read from GEAR?-->
<parameter name="zbcal" type="float">3594.9</parameter>
<!--Min threshold energy for which particles are detected-->
<parameter name="thresholdmin" type="float">40</parameter>
<!--Max threshold energy for which particles are detected-->
<parameter name="thresholdmax" type="float">260</parameter>
<!--scale factor for background density-->
<parameter name="densityScale" type="float">1.</parameter>
<!--If bool true it writes out all electrons/photons hitting the BCAL-->
<parameter name="detectAll" type="bool">1</parameter>
<!--If bool true it smears the energy (and momentum) of electrons/photons hitting the BCAL-->
<parameter name="smearEnergy" type="bool">1</parameter>
</processor>

 <processor name="Check" type="Check">
 <!--Simple processor to test the marlin application. Prints run and event number.-->
  <parameter name="RecoPartCollectionName" type="string" lcioInType="ReconstructedParticle">SimdetParticles</parameter>
</processor>



 <processor name="MyAbsCalibr" type="AbsCalibr">
 <!-- Calorimeter Abslute Energy Calibration-->
  <!--Calorimeter coeffs-->
  <parameter name="Coeff" type="FloatVec">33.0235 93.5682 21.1963  </parameter>
  <!--Calorimeter cuts-->
  <parameter name="Cuts" type="FloatVec">8.5e-05 8.5e-05 0.0004375  </parameter>
  <!--Number of layers in zone-->
  <parameter name="NLayer" type="IntVec">30 10 40  </parameter>
</processor>

 <processor name="MyAidaPerEventCommitterProcessor" type="AidaPerEventCommitterProcessor">
 <!--AidaPerEventCommitterProcessor writes all Aida Histogramms to disk, if check flag is enabled; needs to be the last processor before OutputProcessor-->
</processor>

 <processor name="MyBiasedResidualsProcessor" type="BiasedResidualsProcessor">
 <!--BiasedResidualsProcessor: Fill biased residuals of hits in tracks into AIDA histgram-->
  <!--Maximal value in xy histogram (default:  0.3 mm)-->
  <parameter name="HistogramMaxValueXY" type="float">0.3 </parameter>
  <!--Maximal value in z histogram (default:  1.0 mm)-->
  <parameter name="HistogramMaxValueZ" type="float">1 </parameter>
  <!--Minimum value in xy histogram (default: -0.3 mm)-->
  <parameter name="HistogramMinValueXY" type="float">-0.3 </parameter>
  <!--Minimum value in z histogram (default: -1.0 mm)-->
  <parameter name="HistogramMinValueZ" type="float">-1 </parameter>
  <!--Name of the input tracks collection-->
  <parameter name="InputTracks" type="string" lcioInType="Track">TPCSeedTracks </parameter>
</processor>

 <processor name="MyCEDViewer" type="CEDViewer">
 <!--CEDViewer: event display of LCIO objects  - based on CED by A.Zhelezov.-->
  <!--collection to be displayed ( ColName, marker type[0-2], size)-->
  <!--parameter name="DrawCollection" type="StringVec">DrawCollection 0 3  </parameter-->
</processor>

 <processor name="MyCalorimeterFinalStage" type="CalorimeterFinalStage">
 <!--CalorimeterFinalStage -->
  <!--Cluster Input Collection Name-->
  <parameter name="ClusterInputCollection" type="string" lcioInType="Cluster">CalorimeterStage3Clusters </parameter>
  <!--Cluster Output Collection Name-->
  <parameter name="ClusterOutputCollection" type="string" lcioOutType="Cluster">ClustersMagic </parameter>
  <!--Minimal Hits in Cluster-->
  <parameter name="MinimalHits" type="int">0 </parameter>
</processor>

 <processor name="MyChannelMapperProcessor" type="ChannelMapperProcessor">
 <!--ChannelMapperProcessor changes cellID0 to map from hardware channel numbers to sowftware/logical channel numbers.-->
  <!--Name of the input collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="TrackerPulse">TPCPulses </parameter>
  <!--Name of the collection with the mapping-->
  <parameter name="MappingCollectionName" type="string">TPCChannelMapping </parameter>
  <!--Optional: Name of output collection-->
  <!--parameter name="OutputCollectionName" type="string">TPCPulsesMapped </parameter-->
  <!--if not 0 the output collection is set transient (only if OutputCollectionName defined)-->
  <parameter name="SetOutputTransient" type="int">0 </parameter>
</processor>

 <processor name="MyChargeDistributionProcessor" type="ChargeDistributionProcessor">
 <!--ChargeDistributionProcessor maps charge to padplane ...-->
  <!--Intervall between two bunchcrossings-->
  <parameter name="BunchIntervall" type="double">369 </parameter>
  <!--Value of Induction Field-->
  <parameter name="EInd" type="float">5000 </parameter>
  <!--Value of Transfer Field 1-->
  <parameter name="ETrans1" type="float">2500 </parameter>
  <!--Value of Transfer Field 2-->
  <parameter name="ETrans2" type="float">2500 </parameter>
  <!--DriftGas-->
  <parameter name="Gas" type="string">TDR </parameter>
  <!--Name of the Input collection with drifted electrons-->
  <parameter name="InputCollectionName" type="string" lcioInType="SimTrackerHit">AmplifiedElectrons </parameter>
  <!--Name of the Output GEM collection-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="LCGenericObject">DistributedElectrons </parameter>
  <!--switch off writing of output collection-->
  <parameter name="Transient" type="int">0 </parameter>
  <!--Length of a zBin-->
  <parameter name="zBinLength" type="double">1 </parameter>
</processor>

 <processor name="MyClusterCheater" type="ClusterCheater">
 <!--Creates true clusters...-->
  <!--Calorimeter Collection Names-->
  <parameter name="CaloCollections" type="StringVec" lcioInType="CalorimeterHit">ECAL HCAL  </parameter>
  <!--SimCaloHit to CaloHit Relations Collection Name-->
  <parameter name="RelCollection" type="string" lcioInType="LCRelation">RelationCaloHit </parameter>
  <!--Collection of True Clusters-->
  <parameter name="TrueClusterCollection" type="string" lcioOutType="Cluster">TrueClusters </parameter>
  <!--Relation Collection Cluster to MCP-->
  <parameter name="TrueClusterToMCPCollection" type="string" lcioOutType="LCRelation">TrueClusterToMCP </parameter>
</processor>

 <processor name="MyClusterCheater5_3" type="ClusterCheater5_3">
 <!--Creates true clusters...-->
  <!--Calorimeter Collection Names-->
  <parameter name="CaloCollections" type="StringVec" lcioInType="CalorimeterHit">ECAL HCAL  </parameter>
  <!--Not to connect hist from  backscatter-->
  <parameter name="CutBackscatter" type="int">1 </parameter>
  <!--Calorimeter Collection Names-->
  <parameter name="MCParticleCollection" type="string" lcioInType="MCParticle">MCParticlesSkimmed </parameter>
  <!--Minimal number of hits in cluster-->
  <parameter name="MinHitsInCluster" type="int">0 </parameter>
  <!--SimCaloHit to CaloHit Relations Collection Name-->
  <parameter name="RelCollection" type="string" lcioInType="LCRelation">RelationCaloHit </parameter>
  <!--Collection of True Clusters-->
  <parameter name="TrueClusterCollection" type="string" lcioOutType="Cluster">TrueClusters </parameter>
  <!--Relation Collection Cluster to MCP-->
  <parameter name="TrueClusterToMCPCollection" type="string" lcioOutType="LCRelation">TrueClusterToMCP </parameter>
</processor>

 <processor name="MyConditionsProcessor" type="ConditionsProcessor">
 <!--ConditionsProcessor provides access to conditions data  transparently from LCIO files or a databases, using LCCD-->
  <!--Initialization of a conditions database handler-->
  <!--parameter name="DBCondHandler" type="StringVec">conditionsName /lccd/myfolder HEAD  </parameter-->
  <!--Initialization of a conditions db file handler-->
  <!--parameter name="DBFileHandler" type="StringVec">conditionsName conditions.slcio collectionName  </parameter-->
  <!--Initialization string for conditions database-->
  <parameter name="DBInit" type="string">localhost:lccd_test:calvin:hobbes </parameter>
  <!--Initialization of a data file handler-->
  <!--parameter name="DataFileHandler" type="StringVec">conditionsName  </parameter-->
  <!--Initialization of a simple conditions file handler-->
  <!--parameter name="SimpleFileHandler" type="StringVec">conditionsName conditions.slcio collectionName  </parameter-->
</processor>

 <processor name="MyConversionTagger" type="ConversionTagger">
 <!--ConversionTagger processor does conversion and V0 tagging-->
  <!--even tag MC conv/V0 when only one track reconstructed?-->
  <!--parameter name="CheatEvenMore" type="bool">false </parameter-->
  <!--whether or not to use MC info for conv/V0 finding-->
  <!--parameter name="CheatMode" type="bool">false </parameter-->
  <!--max distance of closest approach between two  helices (mm)-->
  <!--parameter name="DistCut" type="double">1 </parameter-->
  <!--Input Collection Names (TRACK or RECONSTRUCTEDPARTICLE)-->
  <parameter name="InputCollections" type="StringVec" lcioInType="ReconstructedParticle"> </parameter>
  <!--Kshort candidates: max deviation of candidate mass from PDG Kshort mass (GeV)-->
  <!--parameter name="MassRangeKaon" type="double">0.005 </parameter-->
  <!--Lambda candidates: max deviation of candidate mass from PDG Lambda mass-->
  <!--parameter name="MassRangeLambda" type="double">0.002 </parameter-->
  <!--upper mass limit for photon conversion candidates (GeV)-->
  <!--parameter name="MassRangePhoton" type="double">0.005 </parameter-->
  <!--min distance of V0 candidates from IP (mm)-->
  <!--parameter name="MinDistFromIP" type="double">1 </parameter-->
  <!--list of particles types to look for (described in terms of positive PDG value)-->
  <!--parameter name="PdgToTag" type="IntVec">22 310 3122  </parameter-->
</processor>

 <processor name="MyConvertToMIPScale" type="ConvertToMIPScale">
 <!--transforms the energy amplitude of each calorimeter hit passing the cut into the MIP scale-->
  <!--Cut in MIPs on the amplitudes in the ECAL collection-->
  <parameter name="CutECAL" type="float">0 </parameter>
  <!--Cut in MIPs on the amplitudes in the HCAL collection-->
  <parameter name="CutHCAL" type="float">0 </parameter>
  <!--ECAL Input Collection Name-->
  <parameter name="ECALInputCollectionName" type="string" lcioInType="CalorimeterHit">ECAL </parameter>
  <!--ECAL Output Collection Name, stores calorimeter hits with amplitudes in MIP energy scale-->
  <parameter name="ECALOutputCollectionName" type="string" lcioOutType="CalorimeterHit">ECAL_MIP </parameter>
  <!--HCAL Input Collection Name-->
  <parameter name="HCALInputCollectionName" type="string" lcioInType="CalorimeterHit">HCAL </parameter>
  <!--HCAL Output Collection Name, stores calorimeter hits with amplitudes in MIP energy scale-->
  <parameter name="HCALOutputCollectionName" type="string" lcioOutType="CalorimeterHit">HCAL_MIP </parameter>
  <!--Coefficients for the MIP calibration in the ECAL in GeV/MIP-->
  <parameter name="MIPCoeffEcal" type="FloatVec">1 1  </parameter>
  <!--Coefficients for the MIP calibration in the HCAL in GeV/MIP-->
  <parameter name="MIPCoeffHcal" type="FloatVec">1  </parameter>
</processor>

 <processor name="MyCountsToPrimaryElectronsProcessor" type="CountsToPrimaryElectronsProcessor">
 <!--CountsToPrimaryElectronsProcessor converts FADC counts into primary electrons, the conversion factors are provided by LCCD. Gain corrections are provided by the GainCorrectorProcessor-->
  <!--Name of the collection containing the channel corrections-->
  <!--parameter name="ChannelCorrectionCollection" type="string">TPCChannelCorrection </parameter-->
  <!--Name of the input collection as stored in the LCIO file-->
  <parameter name="InputTrackerPulses" type="string" lcioInType="TrackerData">TPCPulses </parameter>
  <!--Name of the collection to be stored in the LCIO file-->
  <parameter name="OutputTrackerPulses" type="string" lcioOutType="TrackerData">TPCPulses </parameter>
  <!--if not 0 the output collection is set transient-->
  <!--parameter name="SetOutputTransient" type="bool">true </parameter-->
  <!--Name of the collection containing the TPC conditions-->
  <!--parameter name="TPCConditionsCollection" type="string">TPCConditions </parameter-->
</processor>

 <processor name="MyCurlKillerProcessor" type="CurlKillerProcessor">
 <!--CurlKillerProcessor: Using a 2D(r-phi) histogram, hits from patterns (curlers) traversing the TPC in Z whilst retaining constant r-phi are removed from a new TrackerHit collection -->
  <!--Bin size in square root of pad multiples-->
  <parameter name="BinSize" type="int">2 </parameter>
  <!--Name of the cut away TrackerHit collection-->
  <parameter name="CutCollectionName" type="string" lcioOutType="TrackerHit">cutTPCTrackeHits </parameter>
  <!--Name of the TrackerHit collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="TrackerHit">TPCTrackerHits </parameter>
  <!--Cut for the number of hits allowed in one bin-->
  <parameter name="MultiplicityCut" type="int">4 </parameter>
  <!--Name of the remaining TrackerHit collection-->
  <parameter name="RemainingCollectionName" type="string" lcioOutType="TrackerHit">remainingTPCTrackerHits </parameter>
</processor>

 <processor name="MyCutOnCosThetaQQbar" type="CutOnCosThetaQQbar">
 <!--The output condition of this processor is false as long as the |cos(theta)| > cutCosTheta and true otherwise.-->
  <!--cut on |cos(theta)|-->
  <parameter name="cutCosTheta" type="double">1 </parameter>
</processor>

 <processor name="MyCutOnGEANT4Bug" type="CutOnGEANT4Bug">
 <!--The output condition of this processor is true as long as no track has more than a factor of k more energy deposited in the calorimeter as its energy given by momentum and mass. This should cut out events where GEANT4 produces additional energy depositions. If at least one such a track is found the return value is false. Only tracks with an energy larger than eMin are taken into account.-->
  <!--Calibration coefficients for ECAL-->
  <parameter name="calibrCoeffECAL" type="FloatVec">33.0235 93.5682  </parameter>
  <!--Calibration coefficients for HCAL-->
  <parameter name="calibrCoeffHCAL" type="FloatVec">21.1963  </parameter>
  <!--name of the LC Relation collection between Calorimeterhits and SimCalorimeterhits-->
  <parameter name="colNameRelationCaloHitToSimCaloHit" type="string">RelationCaloHit </parameter>
  <!--name of the LC Relation collection between Tracks and MC particles-->
  <parameter name="colNameRelationTrackToMCP" type="string">TrueTrackToMCP </parameter>
  <!--name of the Track collection-->
  <parameter name="colNameTracks" type="string">Tracks </parameter>
  <!--minimal energy of tracks taken into account (in GeV)-->
  <parameter name="eMin" type="double">5 </parameter>
  <!--if the track has more than k times its MC energy deposited the return value is set to false-->
  <parameter name="k" type="double">1.75 </parameter>
</processor>

 <processor name="MyDSTAIDAPlotProcessor" type="DSTAIDAPlotProcessor">
 <!--Plots various outputs from the flavour tag-->
  <!--Name of the collection of ReconstructedParticles that is the jet-->
  <parameter name="JetCollectionName" type="string" lcioInType="ReconstructedParticle">FTSelectedJets </parameter>
</processor>

 <processor name="MyDSTCollectionProcessor" type="DSTCollectionProcessor">
 <!--DSTCollectionProcessor - Takes the flavour tag info, mc truth info, and some NN  input info, and adds it as Particle ID info to the jets, for the DSTs-->
  <!--Debugging option-->
  <parameter name="Debug" type="int">0 </parameter>
  <!--Name of the LCFloatVec Collection containing the flavour tags (in same order as jet collection)-->
  <parameter name="FlavourTagCollection" type="string" lcioInType="LCFloatVec">FlavourTag </parameter>
  <!--Name of the LCFloatVec Collection that contains the flavour tag inputs (in same order as jet collection)-->
  <parameter name="FlavourTagInputsCollection" type="string" lcioInType="LCFloatVec">FlavourTagInputs </parameter>
  <!--Name of the collection of ReconstructedParticles that is the jet-->
  <parameter name="JetCollectionName" type="string" lcioInType="ReconstructedParticle">Jets </parameter>
  <!--Name of the LCIntVec collection containing the true flavour of the jets (same order as jets)-->
  <parameter name="TrueJetFlavourCollection" type="string" lcioInType="LCFloatVec">TrueJetFlavour </parameter>
</processor>

 <processor name="MyDSTPlotProcessor" type="DSTPlotProcessor">
 <!--Plots various outputs from the flavour tag-->
  <!--Checks the DST parameters against the full parameters - gives a lot of print out-->
  <parameter name="CheckDSTParameters" type="int">0 </parameter>
  <!--Name of the LCFloatVec Collection containing the flavour tags, only need this if you want to check DST parameters-->
  <!--parameter name="FlavourTagCollection" type="string">FlavourTag </parameter-->
  <!--Name of the LCFloatVec Collection that contains the flavour tag inputs, only need this if you want to check DST parameters-->
  <!--parameter name="FlavourTagInputsCollection" type="string">FlavourTagInputs </parameter-->
  <!--Name of the collection of ReconstructedParticles that is the jet-->
  <parameter name="JetCollectionName" type="string" lcioInType="ReconstructedParticle">FTSelectedJets </parameter>
  <!--Filename for the output-->
  <parameter name="OutputFilename" type="string">DSTPlotProcessorOutput </parameter>
  <!--Name of the LCIntVec collection containing the true flavour of the jets, only need this if you want to check DST parameters-->
  <!--parameter name="TrueJetFlavourCollection" type="string">TrueJetFlavour </parameter-->
</processor>

 <processor name="MyDrawMCParticles" type="DrawMCParticles">
 <!--DrawMCParticles draws the MC Particle prediction w/o calorimeters in the ced display-->
  <!--Energy Cut in GeV-->
  <parameter name="EnergyCut" type="double">0.01 </parameter>
  <!--Name of the MCParticle collection-->
  <parameter name="MCCollectionName" type="string">MCParticlesSkimmed </parameter>
  <!--Wait for Keyboard before proceed-->
  <parameter name="WaitForKeyboard" type="int">1 </parameter>
  <!--Radius of the innermost detector component (VTX) in cylindrical coordinates-->
  <parameter name="rIn" type="double">15.5 </parameter>
  <!--z coordinate of the innermost detector component (VTX) in cylindrical coordinates-->
  <parameter name="zIn" type="double">50 </parameter>
</processor>

 <processor name="MyDriftProcessor" type="DriftProcessor">
 <!--DriftProcessor drifts electrons to GEM structure ...-->
  <!--Drift Field-->
  <parameter name="DriftField" type="float">260 </parameter>
  <!--DriftGas-->
  <parameter name="Gas" type="string">TDR </parameter>
  <!--Name of the input collection with primary electrons-->
  <parameter name="InputCollectionName" type="string" lcioInType="SimTrackerHit">PrimaryIonisation </parameter>
  <!--Name of the output collection with drifted electrons-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="SimTrackerHit">DriftedElectrons </parameter>
  <!--switch off writing of output collection-->
  <parameter name="Transient" type="int">0 </parameter>
</processor>

 <processor name="MyDumpHitsInTracksProcessor" type="DumpHitsInTracksProcessor">
 <!--DumpHitsInTracksProcessor: Dump coordinates of hits in tracks-->
  <!--Name of the input tracks collection-->
  <parameter name="InputTracks" type="string" lcioInType="Track">TPCSeedTracks </parameter>
</processor>

 <processor name="MyDumpNTracksProcessor" type="DumpNTracksProcessor">
 <!--DumpNTracksProcessor: Dump coordinates of hits in tracks-->
  <!--Name of the input tracks collection-->
  <parameter name="InputTracks" type="string" lcioInType="Track">TPCSeedTracks </parameter>
</processor>

 <processor name="MyDumpPadCentresProcessor" type="DumpPadCentresProcessor">
 <!--DumpPadCentresProcessor: Dump coordinates of pads with charge-->
  <!--Name of the input pulses collection-->
  <parameter name="InputPulses" type="string" lcioInType="TrackerPulse">TPCPulses </parameter>
</processor>

 <processor name="MyDumpResidualsProcessor" type="DumpResidualsProcessor">
 <!--DumpResidualsProcessor: Dump residuals of hits in tracks-->
  <!--Name of the input tracks collection-->
  <parameter name="InputTracks" type="string" lcioInType="Track">TPCSeedTracks </parameter>
</processor>

 <processor name="MyEMShowerFinder" type="EMShowerFinder">
 <!--a photon finder processor based on the KIT and KITutil 'classes and fuctions'-->
  <!--To do the cleaning on hits or not -->
  <parameter name="Cleaning" type="string">YES </parameter>
  <!--Cosine of the angle for merging -->
  <parameter name="Coscut" type="double">0.95 </parameter>
  <!--limits the amount of information written to std out (0 - none, 9 - maximal information)-->
  <parameter name="DebugLevel" type="int">0 </parameter>
  <!--Square of distance cut for merging -->
  <parameter name="Distcut" type="double">35 </parameter>
  <!--draw objects on CED-->
  <parameter name="DrawOnCED" type="int">0 </parameter>
  <!--Levels for central loop in MIP -->
  <parameter name="Levels" type="FloatVec">0.1 1.5 2.5 4 6 9 16 26 41 65  </parameter>
  <!--Minimal Number of hits for ground level cluster -->
  <parameter name="MinHit0" type="int">4 </parameter>
  <!--Minimal Number of hits for i-th level cluster -->
  <parameter name="MinHitSplit" type="int">2 </parameter>
  <!--Number of levels for central loop -->
  <parameter name="NumberOfLevels" type="int">10 </parameter>
  <!--Fluctuation suprresion cut-->
  <parameter name="Rcut" type="double">0.4 </parameter>
  <!--At which number of neighbors to put the threshold, condition is < so you need to put N+1 -->
  <parameter name="TopologicalCut" type="int">5 </parameter>
  <!--ECAL Collection Name-->
  <parameter name="colNameECAL" type="string">ECAL </parameter>
  <!--Name of the collection of EM shower candidates-->
  <parameter name="collectionNameOfEMShowerCandidates" type="string">EMShowerCandidates </parameter>
  <!--cut on energy deviation of em shower candidates from estimated energy ( abs( (Ecluster - Eestimated)/Eestimated ) < cut )-->
  <parameter name="energyDeviationCut" type="double">0.25 </parameter>
  <!--cut on the probability density to assign hits to shower cores-->
  <parameter name="probabilityDensityCut" type="double">0.001 </parameter>
</processor>

 <processor name="MyETDDigiProcessor" type="ETDDigiProcessor">
 <!--ETDDigiProcessor creates ETD TrackerHits from SimTrackerHits-->
  <!--Name of the SimTrackerHit collection-->
  <parameter name="CollectionName" type="string" lcioInType="SimTrackerHit">ftd01_ETD </parameter>
  <!--Momentum Cut For D Rays (GeV)-->
  <parameter name="MomentumCutForDRays" type="float">10 </parameter>
  <!--Name of the TrackerHit output collection-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="TrackerHit">ETDTrackerHits </parameter>
  <!--Point Resolution in ETD-->
  <parameter name="PointResolution" type="float">0.01 </parameter>
  <!--Remove D rays?-->
  <parameter name="RemoveDrays" type="int">0 </parameter>
</processor>

 <processor name="MyEUTelAutoPedestalNoiseProcessor" type="EUTelAutoPedestalNoiseProcessor">
 <!--EUTelAutoPedestalNoiseProcessor produces initial pedestal / noise / status with user provided values-->
  <!--The initial value of noise (one value for detector)-->
  <!--parameter name="InitNoiseValue" type="FloatVec">1 1 1 1 1 1  </parameter-->
  <!--The initial value of pedestal (one value for detector)-->
  <!--parameter name="InitPedestalValue" type="FloatVec">0 0 0 0 0 0  </parameter-->
  <!--Noise local collection-->
  <parameter name="NoiseCollectionName" type="string" lcioOutType="TrackerData">noise </parameter>
  <!--Pedestal local collection-->
  <parameter name="PedestalCollectionName" type="string" lcioOutType="TrackerData">pedestal </parameter>
  <!--Pixel status collection-->
  <parameter name="StatusCollectionName" type="string" lcioOutType="TrackerRawData">status </parameter>
</processor>

 <processor name="MyEUTelCalculateEtaProcessor" type="EUTelCalculateEtaProcessor">
 <!--EUTelCalculateEtaProcessor calculates the eta function for a given set of clusters-->
  <!--Input cluster collection-->
  <parameter name="ClusterCollectionName" type="string" lcioInType="TrackerPulse">cluster </parameter>
  <!--To use only kGoodQuality write 0 here-->
  <parameter name="ClusterQualitySelection" type="int">0 </parameter>
  <!--Write FULL: full cluster, NxMPixel: for a NxM sub-cluster, NPixel: to use only N pixel-->
  <parameter name="ClusterTypeSelection" type="string">FULL </parameter>
  <!--Set the name of the Eta collection along x-->
  <parameter name="EtaXCollectionName" type="string">xEtaCondition </parameter>
  <!--Set the name of the Eta collection along y-->
  <parameter name="EtaYCollectionName" type="string">yEtaCondition </parameter>
  <!--Write here how many events you want to use for eta calculation (-1 for all)-->
  <parameter name="EventNumber" type="int">-1 </parameter>
  <!--The number of pixel with the highest signal (only for NPixel)-->
  <parameter name="NPixelSize" type="int">5 </parameter>
  <!--Write here in how many bins the seed pixel should be divided (x and y)-->
  <parameter name="NumberOfBins" type="IntVec">1000 1000  </parameter>
  <!--The size along x and y of the subcluster (only for NxMPixel)-->
  <parameter name="NxMPixelClusterSize" type="IntVec">3 3  </parameter>
  <!--This is the name of the output condition file-->
  <parameter name="OutputEtaFileName" type="string">etafile </parameter>
</processor>

 <processor name="MyEUTelCalibrateEventProcessor" type="EUTelCalibrateEventProcessor">
 <!--EUTelCalibrateEventProcessor subtracts the pedestal value from the input data-->
  <!--Name of the output calibrated data collection-->
  <parameter name="CalibratedDataCollectionName" type="string" lcioOutType="TrackerData">data </parameter>
  <!--Flag to switch on (1) or off (0) the detector debug histogram filling-->
  <parameter name="DebugHistoFilling" type="bool">false </parameter>
  <!--This is the name of the histogram information file-->
  <parameter name="HistoInfoFileName" type="string">histoinfo.xml </parameter>
  <!--Threshold of pixel SNR for hit rejection-->
  <parameter name="HitRejectionCut" type="float">3.5 </parameter>
  <!--Maximum allowed number of rejected pixel per event-->
  <parameter name="MaxNoOfRejectedPixels" type="int">3000 </parameter>
  <!--Noise from the condition file-->
  <parameter name="NoiseCollectionName" type="string" lcioInType="TrackerData">noise </parameter>
  <!--Pedestal from the condition file-->
  <parameter name="PedestalCollectionName" type="string" lcioInType="TrackerData">pedestal </parameter>
  <!--Flag to switch on (1) or off (0) the common mode suppression algorithm-->
  <parameter name="PerformCommonMode" type="bool">true </parameter>
  <!--Input raw data collection-->
  <parameter name="RawDataCollectionName" type="string" lcioInType="TrackerRawData">rawdata </parameter>
  <!--Pixel status from the condition file-->
  <parameter name="StatusCollectionName" type="string" lcioInType="TrackerRawData">status </parameter>
</processor>

 <processor name="MyEUTelClusterFilter" type="EUTelClusterFilter">
 <!--EUTelClusterFilter is a very powerful tool. It allows to select among an input collection of TrackerPulse
only the clusters fulfilling a certain set of selection criteria.
The user can modify the switch on and off each selection cut and set the proper value for that via the processor parameter.-->
  <!--This is the minimum allowed total charge in to a cluster.
One floating point number for each sensor in the telescope-->
  <parameter name="ClusterMinTotalCharge" type="FloatVec">90 75 80  </parameter>
  <!--This is the minimum charge that a cluster of N pixels has to have.
The first figure has to be the number of pixels to consider in the cluster, 
then one float number for each sensor.-->
  <parameter name="ClusterNMinCharge" type="FloatVec">9 90 75 80  </parameter>
  <!--This is the minimum SNR that a cluster of N pixels has to have.
The first figure has to be the number of pixels to consider in the cluster, 
then one float number for each sensor. Setting N = 0 is enough to disable the cut.-->
  <parameter name="ClusterNMinSNR" type="FloatVec">9 25 21 20  </parameter>
  <!--This is the minimum charge that a cluster of N times N pixels has to have.
The first figure is the subcluster size in pixels (odd number), then one floating number for each 
planes. To switch this selection off, set all numbers to zero.-->
  <parameter name="ClusterNxNMinCharge" type="FloatVec">3 0 0 0  </parameter>
  <!--This is the minimum SNR that a cluster of N times N pixels has to have.
The first figure is the subcluster size in pixels (odd number), then one floating number for each 
planes. To switch this selection off, set at least the first number to zero.-->
  <parameter name="ClusterNxNMinSNR" type="FloatVec">3 0 0 0  </parameter>
  <!--This is the required quality for the cluster.
One integer number for each detector according to ClusterQuality.
Put a negative number to disable the cut-->
  <parameter name="ClusterQuality" type="IntVec">0 0 0  </parameter>
  <!--This is the input Tracker Pulse collection that should be filtered-->
  <parameter name="InputPulseCollectionName" type="string" lcioInType="TrackerPulse">cluster </parameter>
  <!--Define here ROI's. The first number (integer) is the detector ID.
The other four float are xBotLeft  yBotLeft xTopRight yTopRight.
To disable it, just put a negative number as detector ID.-->
  <parameter name="InsideRegion" type="FloatVec">-1 10 10 40 40  </parameter>
  <!--This is maximum allowed cluster noise.
One floating number for each detector. Write a negative number to disable the cut-->
  <parameter name="MaxClusterNoise" type="FloatVec">50 45 48  </parameter>
  <!--This is the maximum allowed number of cluster per plane.
 One integer number for each detector. Write a negative number to disable the cut-->
  <parameter name="MaxClusterPerPlane" type="IntVec">-1 -1 -1  </parameter>
  <!--This is the minimum required number of cluster per plane.
One integer number for each detector. Write 0 to disable the cut-->
  <parameter name="MinClusterPerPlane" type="IntVec">0 0 0  </parameter>
  <!--This is the minimum allow total cluster SNR
One floating number for each detector. Write 0 to disable the cut-->
  <parameter name="MinTotalClusterSNR" type="FloatVec">10 12 11  </parameter>
  <!--This is the name of the noise collection.
The presence of this collection in the event is allowing all the noise based selection cuts-->
  <!--parameter name="NoiseCollectionName" type="string">noiseDB </parameter-->
  <!--This is the output Tracker Pulse collection containing the filtered clusters-->
  <parameter name="OutputPulseCollectionName" type="string" lcioOutType="TrackerPulse">filteredcluster </parameter>
  <!--Define here ROI's. The first number (integer) is the detector ID.
The other four float are xBotLeft  yBotLeft xTopRight yTopRight.
To disable it, just put a negative number as detector ID.-->
  <parameter name="OutsideRegion" type="FloatVec">-1 10 10 40 40  </parameter>
  <!--Setting this to true will select only events having the same number 
of hits for each plane.-->
  <parameter name="SameNumberOfHits" type="bool">false </parameter>
  <!--This is the minimum allowed charge that the seed pixel of a cluster has to have.
One floating number for each detector-->
  <parameter name="SeedMinCharge" type="FloatVec">20 25 21  </parameter>
  <!--This is the minimum allowed SNR that the seed pixel of a cluster has to have.
One floating number for each detector. Set to 0 to disable-->
  <parameter name="SeedMinSNR" type="FloatVec">10 12 14  </parameter>
  <!--If true, a SkipEventException is thrown if after selection
there are no cluster left.-->
  <!--parameter name="SkipEmptyEvent" type="bool">false </parameter-->
  <!--This is the name of the status collection.
The presence of this collection in the event is allowing all the noise based selection cuts-->
  <!--parameter name="StatusCollectionName" type="string">statusDB </parameter-->
</processor>

 <processor name="MyEUTelClusterSeparationProcessor" type="EUTelClusterSeparationProcessor">
 <!--EUTelClusterSeparationProcessor separates merging clusters-->
  <!--Cluster collection name -->
  <parameter name="ClusterCollectionName" type="string" lcioInType="TrackerPulse">cluster </parameter>
  <!--Cluster output collection name-->
  <parameter name="ClusterOutputCollectionName" type="string" lcioOutType="TrackerPulse">splitcluster </parameter>
  <!--Minimum distance allowed between separated clusters (0 == only touching clusters)-->
  <parameter name="MinimumDistance" type="float">0 </parameter>
  <!--Select which algorithm to use for cluster separation-->
  <parameter name="SeparationAlgorithm" type="string">FlagOnly </parameter>
</processor>

 <processor name="MyEUTelClusteringProcessor" type="EUTelClusteringProcessor">
 <!--EUTelClusteringProcessor is looking for clusters into a calibrated pixel matrix.-->
  <!--Threshold in SNR for cluster identification-->
  <parameter name="ClusterCut" type="float">3 </parameter>
  <!--The list of cluster N to be filled.For example 7 means filling the cluster spectra with the 7 most significant pixels-->
  <!--parameter name="ClusterN" type="IntVec">4 9 14 19 25  </parameter-->
  <!--The list of cluster NxN to be filled.For example 3 means filling the 3x3 histogram spectrum-->
  <!--parameter name="ClusterNxN" type="IntVec">3 5  </parameter-->
  <!--Maximum allowed cluster size along x (only odd numbers)-->
  <parameter name="ClusterSizeX" type="int">5 </parameter>
  <!--Maximum allowed cluster size along y (only odd numbers)-->
  <parameter name="ClusterSizeY" type="int">5 </parameter>
  <!--Select here which algorithm should be used for clustering.
Available algorithms are:
-> FixedFrame: for custer with a given size-->
  <parameter name="ClusteringAlgo" type="string">FixedFrame </parameter>
  <!--This is the name of the histogram information file-->
  <parameter name="HistoInfoFileName" type="string">histoinfo.xml </parameter>
  <!--Switch on or off the histogram filling-->
  <parameter name="HistogramFilling" type="bool">true </parameter>
  <!--Minimum distance between sparsified pixel ( touching == sqrt(2)) -->
  <parameter name="MinDistance" type="float">0 </parameter>
  <!--Input calibrated data not zero suppressed collection name-->
  <parameter name="NZSDataCollectionName" type="string" lcioInType="TrackerData">data </parameter>
  <!--Noise (input) collection name-->
  <parameter name="NoiseCollectionName" type="string" lcioInType="TrackerData">noise </parameter>
  <!--Cluster (output) collection name-->
  <parameter name="PulseCollectionName" type="string" lcioOutType="TrackerPulse">cluster </parameter>
  <!--Threshold in SNR for seed pixel identification-->
  <parameter name="SeedPixelCut" type="float">4.5 </parameter>
  <!--Pixel status (input) collection name-->
  <parameter name="StatusCollectionName" type="string" lcioInType="TrackerRawData">status </parameter>
  <!--Threshold in SNR for clusters contained in ZS data-->
  <parameter name="ZSClusterCut" type="float">3 </parameter>
  <!--Select here which algorithm should be used for clustering.
Available algorithms are:
-> SparseCluster: for cluster in ZS frame
-> SparseCluster2: for cluster in ZS frame with better performance-> FixedFrame: for cluster with a given size-->
  <parameter name="ZSClusteringAlgo" type="string">SparseCluster </parameter>
  <!--Input of Zero Suppressed data-->
  <parameter name="ZSDataCollectionName" type="string" lcioInType="TrackerData">zsdata </parameter>
  <!--Threshold in SNR for seed pixel contained in ZS data-->
  <parameter name="ZSSeedCut" type="float">4.5 </parameter>
</processor>

 <processor name="MyEUTelCopyPedestalProcessor" type="EUTelCopyPedestalProcessor">
 <!--EUTelCopyPedestalProcessor copies the condition data into local writable collections-->
  <!--Noise local collection-->
  <parameter name="NoiseCollectionName" type="string" lcioOutType="TrackerData">noise </parameter>
  <!--Noise input condition-->
  <parameter name="NoiseConditionName" type="string" lcioInType="TrackerData">noiseDB </parameter>
  <!--Pedestal local collection-->
  <parameter name="PedestalCollectionName" type="string" lcioOutType="TrackerData">pedestal </parameter>
  <!--Pedestal input condition-->
  <parameter name="PedestalConditionName" type="string" lcioInType="TrackerData">pedestalDB </parameter>
  <!--Pixel status collection-->
  <parameter name="StatusCollectionName" type="string" lcioOutType="TrackerRawData">status </parameter>
  <!--Status input condition-->
  <parameter name="StatusConditionName" type="string" lcioInType="TrackerRawData">statusDB </parameter>
</processor>

 <processor name="MyEUTelDUTHistograms" type="EUTelDUTHistograms">
 <!--Analysis of DUT performance based on the analytic track fit results-->
  <!--Alignment corrections for DUT: shift in X, Y and rotation around Z-->
  <parameter name="DUTalignment" type="FloatVec">0 0 0  </parameter>
  <!--Print out every DebugEnevtCount event-->
  <parameter name="DebugEventCount" type="int">100 </parameter>
  <!--Maximum allowed distance between fit and matched DUT hit-->
  <parameter name="DistMax" type="double">0.1 </parameter>
  <!--Name of the histogram information file-->
  <parameter name="HistoInfoFileName" type="string">histoinfo.xml </parameter>
  <!--Name of the input DUT hit collection-->
  <parameter name="InputHitCollectionName" type="string" lcioInType="TrackerHit">hit </parameter>
  <!--Name of the input Track collection-->
  <parameter name="InputTrackCollectionName" type="string" lcioInType="Track">testfittracks </parameter>
</processor>

 <processor name="MyEUTelEventViewer" type="EUTelEventViewer">
 <!--Event display-->
  <!--Detector Model-->
  <parameter name="DetectorModel" type="int">99999 </parameter>
  <!--Layer for Tracker Hits-->
  <parameter name="LayerTrackerHit" type="int">-1 </parameter>
  <!--Layer for Tracks-->
  <parameter name="LayerTracks" type="int">-1 </parameter>
  <!--Track collection names-->
  <parameter name="TrackCollections" type="StringVec" lcioInType="Track">testfittrack  </parameter>
  <!--Tracker hit collection names-->
  <parameter name="TrackerHitCollections" type="StringVec" lcioInType="TrackerHit">hit testfithit  </parameter>
  <!--Wait for Keyboard before proceed-->
  <parameter name="WaitForKeyboard" type="int">1 </parameter>
</processor>

 <processor name="MyEUTelFitHistograms" type="EUTelFitHistograms">
 <!--Histogram track fit results-->
  <!--ID of the layer used for beam based alignment check-->
  <parameter name="BeamReferenceID" type="int">0 </parameter>
  <!--Print out every DebugEnevtCount event-->
  <parameter name="DebugEventCount" type="int">100 </parameter>
  <!--Name of the histogram information file-->
  <parameter name="HistoInfoFileName" type="string">histoinfo.xml </parameter>
  <!--Name of the input Track collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="Track">testfittracks </parameter>
  <!--IDs of two layers used to check internal telescope alignment-->
  <parameter name="TelescopeReferenceIDs" type="IntVec">0 1  </parameter>
</processor>

 <processor name="MyEUTelHistogramMaker" type="EUTelHistogramMaker">
 <!--EUTelHistogramMaker fills reference and control histograms-->
  <!--The list of cluster N to be filled.For example 7 means filling the cluster spectra with the 7 most significant pixels-->
  <!--parameter name="ClusterN" type="IntVec">4 9 14 19 25  </parameter-->
  <!--The list of cluster NxN to be filled.For example 3 means filling the 3x3 histogram spectrum-->
  <!--parameter name="ClusterNxN" type="IntVec">3 5  </parameter-->
  <!--This is the name of the histogram information file-->
  <parameter name="HistoInfoFileName" type="string">histoinfo.xml </parameter>
  <!--The name of the noise collection.
Needed to fill in noise related histograms-->
  <!--parameter name="NoiseCollectionName" type="string">noise </parameter-->
  <!--Input tracker pulse collection-->
  <parameter name="PulseCollectionName" type="string" lcioInType="TrackerPulse">pulse </parameter>
  <!--The name of the status collection.
Needed to fill in noise related histograms-->
  <!--parameter name="StatusCollectionName" type="string">status </parameter-->
</processor>

 <processor name="MyEUTelHitMaker" type="EUTelHitMaker">
 <!--EUTelHitMaker is responsible to translate cluster centers from the local frame of reference to the external frame of reference using the GEAR geometry description-->
  <!--Select here how the center of gravity should be calculated.
FULL: using the full cluster
NPixel: using only the first N most significant pixels (set NPixel too)
NxMPixel: using a subframe of the cluster N x M pixels wide (set NxMPixel too).-->
  <parameter name="CoGAlgorithm" type="string">NxMPixel </parameter>
  <!--The name of the collections containing the eta function (x and y respectively)-->
  <!--parameter name="EtaCollectionName" type="StringVec">xEta yEta  </parameter-->
  <!--Enable or disable eta correction-->
  <!--parameter name="EtaSwitch" type="bool">true </parameter-->
  <!--Hit collection name-->
  <parameter name="HitCollectionName" type="string" lcioOutType="TrackerHit">hit </parameter>
  <!--The number of most significant pixels to be used if CoGAlgorithm is "NPixel"-->
  <!--parameter name="NPixel" type="int">9 </parameter-->
  <!--The submatrix size to be used for CoGAlgorithm = "NxMPixel"-->
  <!--parameter name="NxMPixel" type="IntVec">3 3  </parameter-->
  <!--Cluster (pulse) collection name-->
  <parameter name="PulseCollectionName" type="string" lcioInType="TrackerPulse">cluster </parameter>
</processor>

 <processor name="MyEUTelHotPixelKiller" type="EUTelHotPixelKiller">
 <!--EUTelHotPixelKiller periodically check for pixel singing loud too often and remove them from the analysis-->
  <!--This float number [0,1] represents the maximum allowed firing frequency
within the selected number of event per cycle-->
  <parameter name="MaxAllowedFiringFreq" type="float">0.2 </parameter>
  <!--The number of events to be considered for each update cycle-->
  <parameter name="NoOfEventPerCycle" type="int">100 </parameter>
  <!--Pixel status collection-->
  <parameter name="StatusCollectionName" type="string" lcioInType="TrackerRawData">status </parameter>
  <!--The total number of hot pixel cycle-->
  <parameter name="TotalNoOfCycle" type="int">10 </parameter>
</processor>

 <processor name="MyEUTelLineFit" type="EUTelLineFit">
 <!--EUTelLineFit will fit a straight line-->
  <!--Alignment Constants for fifth Telescope Layer:
 off_x, off_y, theta_x, theta_y, theta_z-->
  <!--parameter name="AlignmentConstantsFifthLayer" type="FloatVec">0 0 0 0 0  </parameter-->
  <!--Alignment Constants for fourth Telescope Layer:
 off_x, off_y, theta_x, theta_y, theta_z-->
  <!--parameter name="AlignmentConstantsFourthLayer" type="FloatVec">0 0 0 0 0  </parameter-->
  <!--Alignment Constants for second Telescope Layer:
 off_x, off_y, theta_x, theta_y, theta_z-->
  <!--parameter name="AlignmentConstantsSecondLayer" type="FloatVec">0 0 0 0 0  </parameter-->
  <!--Alignment Constants for sixth Telescope Layer:
 off_x, off_y, theta_x, theta_y, theta_z-->
  <!--parameter name="AlignmentConstantsSixthLayer" type="FloatVec">0 0 0 0 0  </parameter-->
  <!--Alignment Constants for third Telescope Layer:
 off_x, off_y, theta_x, theta_y, theta_z-->
  <!--parameter name="AlignmentConstantsThirdLayer" type="FloatVec">0 0 0 0 0  </parameter-->
  <!--Hit collection name-->
  <parameter name="HitCollectionName" type="string" lcioInType="TrackerHit">hit </parameter>
  <!--Collection name for fitted particle hits (positions)-->
  <parameter name="OutputHitCollectionName" type="string" lcioOutType="TrackerHit">fithits </parameter>
  <!--Collection name for fitted tracks-->
  <parameter name="OutputTrackCollectionName" type="string" lcioOutType="Track">fittracks </parameter>
</processor>

 <processor name="MyEUTelMultiLineFit" type="EUTelMultiLineFit">
 <!--EUTelMultiLineFit will fit several straight lines-->
  <!--Alignment Constants for fifth Telescope Layer:
 off_x, off_y, theta_x, theta_y, theta_z-->
  <!--parameter name="AlignmentConstantsFifthLayer" type="FloatVec">0 0 0 0 0  </parameter-->
  <!--Alignment Constants for fourth Telescope Layer:
 off_x, off_y, theta_x, theta_y, theta_z-->
  <!--parameter name="AlignmentConstantsFourthLayer" type="FloatVec">0 0 0 0 0  </parameter-->
  <!--Alignment Constants for second Telescope Layer:
 off_x, off_y, theta_x, theta_y, theta_z-->
  <!--parameter name="AlignmentConstantsSecondLayer" type="FloatVec">0 0 0 0 0  </parameter-->
  <!--Alignment Constants for sixth Telescope Layer:
 off_x, off_y, theta_x, theta_y, theta_z-->
  <!--parameter name="AlignmentConstantsSixthLayer" type="FloatVec">0 0 0 0 0  </parameter-->
  <!--Alignment Constants for third Telescope Layer:
 off_x, off_y, theta_x, theta_y, theta_z-->
  <!--parameter name="AlignmentConstantsThirdLayer" type="FloatVec">0 0 0 0 0  </parameter-->
  <!--Maximal chi2 for fit of x coordinate.-->
  <!--parameter name="Chi2XMax" type="float">10000 </parameter-->
  <!--Maximal chi2 for fit of y coordinate.-->
  <!--parameter name="Chi2YMax" type="float">10000 </parameter-->
  <!--Maximal allowed distance between hits entering the fit.-->
  <!--parameter name="DistanceMax" type="float">2000 </parameter-->
  <!--Exclude plane from fit.-->
  <!--parameter name="ExcludePlane" type="int">0 </parameter-->
  <!--Hit collection name-->
  <parameter name="HitCollectionName" type="string" lcioInType="TrackerHit">hit </parameter>
  <!--Maximal number of track candidates-->
  <!--parameter name="MaxTrackCandidates" type="int">2000 </parameter-->
  <!--Collection name for fitted particle hits (positions)-->
  <parameter name="OutputHitCollectionName" type="string" lcioOutType="TrackerHit">fithits </parameter>
  <!--Collection name for fitted tracks-->
  <parameter name="OutputTrackCollectionName" type="string" lcioOutType="Track">fittracks </parameter>
</processor>

 <processor name="MyEUTelOutputProcessor" type="EUTelOutputProcessor">
 <!--Writes the current event to the specified LCIO outputfile. Eventually it adds a EORE at the of the file if it was missing Needs to be the last ActiveProcessor.-->
  <!--drops the named collections from the event-->
  <!--parameter name="DropCollectionNames" type="StringVec">TPCHits HCalHits  </parameter-->
  <!--drops all collections of the given type from the event-->
  <!--parameter name="DropCollectionTypes" type="StringVec">SimTrackerHit SimCalorimeterHit  </parameter-->
  <!-- write complete objects in subset collections to the file (i.e. ignore subset flag)-->
  <!--parameter name="FullSubsetCollections" type="StringVec">MCParticlesSkimmed  </parameter-->
  <!--force keep of the named collections - overrules DropCollectionTypes (and DropCollectionNames)-->
  <!--parameter name="KeepCollectionNames" type="StringVec">MyPreciousSimTrackerHits  </parameter-->
  <!-- name of output file -->
  <parameter name="LCIOOutputFile" type="string">outputfile.slcio </parameter>
  <!--write mode for output file:  WRITE_APPEND or WRITE_NEW-->
  <parameter name="LCIOWriteMode" type="string">None </parameter>
  <!--Set it to true to remove intermediate EORE in merged runs-->
  <parameter name="SkipIntermediateEORE" type="bool">true </parameter>
  <!--will split output file if size in kB exceeds given value - doesn't work with APPEND and NEW-->
  <!--parameter name="SplitFileSizekB" type="int">1992294 </parameter-->
</processor>

 <processor name="MyEUTelPedestalNoiseProcessor" type="EUTelPedestalNoiseProcessor">
 <!--EUTelPedestalNoiseProcessor computes the pedestal and noise values of a pixel detector-->
  <!--Set to true if the pedestal should also be saved as ASCII files-->
  <parameter name="ASCIIOutputSwitch" type="bool">true </parameter>
  <!--Perform an additional loop for bad pixel masking-->
  <!--parameter name="AdditionalMaskingLoop" type="bool">true </parameter-->
  <!--Threshold for bad pixel identification-->
  <parameter name="BadPixelMaskCut" type="float">3.5 </parameter>
  <!--Select the algorithm for bad pixel masking-->
  <parameter name="BadPixelMaskingAlgorithm" type="string">NoiseDistribution </parameter>
  <!--Select the algorithm for pede/noise calculation-->
  <parameter name="CalculationAlgorithm" type="string">MeanRMS </parameter>
  <!--First event for pedestal calculation-->
  <parameter name="FirstEvent" type="int">0 </parameter>
  <!--Threshold for rejection of hit pixel (SNR units)-->
  <parameter name="HitRejectionCut" type="float">4 </parameter>
  <!--Last event for pedestal calculation-->
  <parameter name="LastEvent" type="int">-1 </parameter>
  <!--Maximum allowed number of rejected pixels per event-->
  <parameter name="MaxNoOfRejectedPixels" type="int">1000 </parameter>
  <!--Number of common mode suppression iterations-->
  <parameter name="NoOfCMIteration" type="int">1 </parameter>
  <!--Noise collection name-->
  <!--parameter name="NoiseCollectionName" type="string">noiseDB </parameter-->
  <!--The filename (w/o .slcio) to store the pedestal file-->
  <parameter name="OutputPedeFile" type="string">outputpede </parameter>
  <!--Pedestal collection name-->
  <!--parameter name="PedestalCollectionName" type="string">pedestalDB </parameter-->
  <!--Input raw data collection-->
  <parameter name="RawDataCollectionName" type="string" lcioInType="TrackerRawData">rawdata </parameter>
  <!--Status collection name-->
  <!--parameter name="StatusCollectionName" type="string">statusDB </parameter-->
</processor>

 <processor name="MyEUTelRawDataSparsifier" type="EUTelRawDataSparsifier">
 <!--EUTelRawDataSparsifier transform full frame raw data in ZS calibrated data mimicking the EUDRB behavior. -->
  <!--Noise from the condition file-->
  <parameter name="NoiseCollectionName" type="string" lcioInType="TrackerData">noise </parameter>
  <!--Pedestal from the condition file-->
  <parameter name="PedestalCollectionName" type="string" lcioInType="TrackerData">pedestal </parameter>
  <!--Input raw data collection-->
  <parameter name="RawDataCollectionName" type="string" lcioInType="TrackerRawData">rawdata </parameter>
  <!--A vector of float containing for each plane the multiplication factor for the noise-->
  <parameter name="SigmaCut" type="FloatVec">2.5 2.5 2.5 2.5 2.5  </parameter>
  <!--Type of sparsified pixel data structure (use SparsePixelType enum)-->
  <parameter name="SparsePixelType" type="int">1 </parameter>
  <!--Name of the output sparsified data collection-->
  <parameter name="SparsifiedDataCollectionName" type="string" lcioOutType="TrackerData">data </parameter>
  <!--Pixel status from the condition file-->
  <parameter name="StatusCollectionName" type="string" lcioInType="TrackerRawData">status </parameter>
</processor>

 <processor name="MyEUTelStrasMimoTelReader" type="EUTelStrasMimoTelReader">
 <!--Reads the data output file produced by the Strasbourg DAQ.
In principle it should work for each kind of detector, but since there are some
hardcoded numbers it is working for the MimoTel only (for the time being)-->
  <!--Name of the CDS collection-->
  <parameter name="CDSCollectionName" type="string" lcioOutType="TrackerRawData">cds </parameter>
  <!--Name of the Frame0 collection-->
  <parameter name="Frame0CollectionName" type="string" lcioOutType="TrackerRawData">frame0 </parameter>
  <!--Name of the Frame1 collection-->
  <parameter name="Frame1CollectionName" type="string" lcioOutType="TrackerRawData">frame1 </parameter>
  <!--The run to be converted (the number only)-->
  <parameter name="LEPSIRunNumber" type="int">500 </parameter>
  <!--Number of pixels along the x axis-->
  <parameter name="XNoOfPixel" type="int">66 </parameter>
  <!--Number of pixels along the x axis-->
  <parameter name="YNoOfPixel" type="int">256 </parameter>
</processor>

 <processor name="MyEUTelSucimaImagerReader" type="EUTelSucimaImagerReader">
 <!--Reads SUCIMA Imager ASCII data files and creates LCEvent with TrackerRawData collection.
Make sure to not specify any LCIOInputFiles in the steering in order to read SUCIMA Imager files.-->
  <!--Number of pixels along X-->
  <parameter name="NoOfXPixel" type="int">512 </parameter>
  <!--Number of pixels along Y-->
  <parameter name="NoOfYPixel" type="int">512 </parameter>
  <!--Input file-->
  <parameter name="SUCIMAImagerFileName" type="string">input.dat </parameter>
</processor>

 <processor name="MyEUTelTestFitter" type="EUTelTestFitter">
 <!--Analytical track fitting processor for EUDET telescope-->
  <!--Ids of layers for which alignment corrections are given-->
  <!--parameter name="AlignLayerIDs" type="IntVec"> </parameter-->
  <!--Rotation around Z for layer alignment-->
  <!--parameter name="AlignLayerRotZ" type="FloatVec"> </parameter-->
  <!--Alignment corrections in X for these layers-->
  <!--parameter name="AlignLayerShiftX" type="FloatVec"> </parameter-->
  <!--Alignment corrections in Y for these layers-->
  <!--parameter name="AlignLayerShiftY" type="FloatVec"> </parameter-->
  <!--Allowed number of missing hits in the track-->
  <parameter name="AllowMissingHits" type="int">0 </parameter>
  <!--Allowed number of hits removed from the track-->
  <parameter name="AllowSkipHits" type="int">0 </parameter>
  <!--Assumed angular spread of the beam [rad]-->
  <!--parameter name="BeamSpread" type="double">0.1 </parameter-->
  <!--Maximum Chi2 for accepted track fit-->
  <parameter name="Chi2Max" type="double">1000 </parameter>
  <!--Collection name for corrected particle positions-->
  <parameter name="CorrectedHitCollectionName" type="string" lcioOutType="TrackerHit">corrfithits </parameter>
  <!--Print out every DebugEnevtCount event-->
  <parameter name="DebugEventCount" type="int">100 </parameter>
  <!--Beam energy [GeV]-->
  <parameter name="Ebeam" type="double">6 </parameter>
  <!--Name of the histogram information file-->
  <parameter name="HistoInfoFileName" type="string">histoinfo.xml </parameter>
  <!--Name of the input TrackerHit collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="TrackerHit">meshit </parameter>
  <!--Flag for storing input (measured) hits in track-->
  <parameter name="InputHitsInTrack" type="bool">false </parameter>
  <!--Ids of layers for which position masks are applied-->
  <!--parameter name="MaskLayerIDs" type="IntVec"> </parameter-->
  <!--Upper mask edge in X-->
  <!--parameter name="MaskMaxX" type="FloatVec"> </parameter-->
  <!--Upper mask edge in Y-->
  <!--parameter name="MaskMaxY" type="FloatVec"> </parameter-->
  <!--Lower mask edge in X-->
  <!--parameter name="MaskMinX" type="FloatVec"> </parameter-->
  <!--Lower mask edge in Y-->
  <!--parameter name="MaskMinY" type="FloatVec"> </parameter-->
  <!--Maximum number of considered hits per plane-->
  <parameter name="MaxPlaneHits" type="int">5 </parameter>
  <!--Chi2 penalty for missing hit in the track-->
  <parameter name="MissingHitPenalty" type="double">0 </parameter>
  <!--Collection name for fitted particle hits (positions)-->
  <parameter name="OutputHitCollectionName" type="string" lcioOutType="TrackerHit">testfithits </parameter>
  <!--Flag for storing output (fitted) hits in track-->
  <parameter name="OutputHitsInTrack" type="bool">true </parameter>
  <!--Collection name for fitted tracks-->
  <parameter name="OutputTrackCollectionName" type="string" lcioOutType="Track">testfittracks </parameter>
  <!--Flag for searching multiple tracks in events with multiple hits-->
  <!--parameter name="SearchMultipleTracks" type="bool">false </parameter-->
  <!--Chi2 penalty for removing hit from the track-->
  <parameter name="SkipHitPenalty" type="double">100 </parameter>
  <!--Ids of layers which should NOT be included in the fit-->
  <!--parameter name="SkipLayerIDs" type="IntVec"> </parameter-->
  <!--Flag for using beam direction constraint in the fit-->
  <!--parameter name="UseBeamConstraint" type="bool">false </parameter-->
  <!--Flag for including DUT measurement in the fit-->
  <parameter name="UseDUT" type="bool">false </parameter>
  <!--Flag for using nominal resolution instead of position errors-->
  <parameter name="UseNominalResolution" type="bool">false </parameter>
  <!--Ids of layers for which position window cut are applied-->
  <!--parameter name="WindowLayerIDs" type="IntVec"> </parameter-->
  <!--Upper window edge in X-->
  <!--parameter name="WindowMaxX" type="FloatVec"> </parameter-->
  <!--Upper window edge in Y-->
  <!--parameter name="WindowMaxY" type="FloatVec"> </parameter-->
  <!--Lower window edge in X-->
  <!--parameter name="WindowMinX" type="FloatVec"> </parameter-->
  <!--Lower window edge in Y-->
  <!--parameter name="WindowMinY" type="FloatVec"> </parameter-->
</processor>

 <processor name="MyEUTelUpdatePedestalNoiseProcessor" type="EUTelUpdatePedestalNoiseProcessor">
 <!--EUTelUpdatePedestalNoiseProcessor periodically updates the pedestaland noise values-->
  <!--The value of the fixed weight (only for fixed weight algorithm-->
  <!--parameter name="FixedWeightValue" type="int">100 </parameter-->
  <!--Noise local collection-->
  <parameter name="NoiseCollectionName" type="string" lcioInType="TrackerData">noise </parameter>
  <!--Pedestal local collection-->
  <parameter name="PedestalCollectionName" type="string" lcioInType="TrackerData">pedestal </parameter>
  <!--A pixel to be monitored (detectorID, xCoord, yCoord). Add as many line as this as you wish-->
  <!--parameter name="PixelMonitored" type="IntVec">0 10 15  </parameter-->
  <!--Raw data collection name-->
  <parameter name="RawDataCollectionName" type="string" lcioInType="TrackerRawData">rawdata </parameter>
  <!--Pixel status collection-->
  <parameter name="StatusCollectionName" type="string" lcioInType="TrackerRawData">status </parameter>
  <!--The algorithm to be used for pedestal update-->
  <parameter name="UpdateAlgorithm" type="string">FixedWeight </parameter>
  <!--How often the algorithm should be applied-->
  <parameter name="UpdateFrequency" type="int">10 </parameter>
</processor>

 <processor name="MyFTDDigiProcessor" type="FTDDigiProcessor">
 <!--FTDDigiProcessor creates FTD TrackerHits from SimTrackerHits-->
  <!--Name of the SimTrackerHit collection-->
  <parameter name="CollectionName" type="string" lcioInType="SimTrackerHit">ftd01_FTD </parameter>
  <!--Momentum Cut For D Rays (GeV)-->
  <parameter name="MomentumCutForDRays" type="float">10 </parameter>
  <!--Name of the TrackerHit output collection-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="TrackerHit">FTDTrackerHits </parameter>
  <!--Point Resolution in FTD-->
  <parameter name="PointResolution" type="float">0.01 </parameter>
  <!--Remove D rays?-->
  <parameter name="RemoveDrays" type="int">0 </parameter>
</processor>

 <processor name="MyFlavourTag" type="FlavourTag">
 <!--Performs a flavour tag using previously trained neural nets-->
  <!--Filename of the previously trained 1 vertex b-tag net-->
  <parameter name="Filename-b_net-1vtx" type="string"> </parameter>
  <!--Filename of the previously trained 2 vertex b-tag net-->
  <parameter name="Filename-b_net-2vtx" type="string"> </parameter>
  <!--Filename of the previously trained 3 (or more) vertex b-tag net-->
  <parameter name="Filename-b_net-3plusvtx" type="string"> </parameter>
  <!--Filename of the previously trained 1 vertex c-tag (b background only) net-->
  <parameter name="Filename-bc_net-1vtx" type="string"> </parameter>
  <!--Filename of the previously trained 2 vertex c-tag (b background only) net-->
  <parameter name="Filename-bc_net-2vtx" type="string"> </parameter>
  <!--Filename of the previously trained 3 (or more) vertex c-tag (b background only) net-->
  <parameter name="Filename-bc_net-3plusvtx" type="string"> </parameter>
  <!--Filename of the previously trained 1 vertex c-tag net-->
  <parameter name="Filename-c_net-1vtx" type="string"> </parameter>
  <!--Filename of the previously trained 2 vertex c-tag net-->
  <parameter name="Filename-c_net-2vtx" type="string"> </parameter>
  <!--Filename of the previously trained 3 (or more) vertex c-tag net-->
  <parameter name="Filename-c_net-3plusvtx" type="string"> </parameter>
  <!--Name of the LCFloatVec Collection that will be created to contain the flavour tag result-->
  <parameter name="FlavourTagCollection" type="string" lcioOutType="LCFloatVec">FlavourTag </parameter>
  <!--Name of the LCFloatVec Collection that contains the flavour tag inputs (in same order as jet collection)-->
  <parameter name="FlavourTagInputsCollection" type="string" lcioInType="LCFloatVec">FlavourTagInputs </parameter>
  <!--Name of the collection of ReconstructedParticles that is the jet-->
  <parameter name="JetCollectionName" type="string" lcioInType="ReconstructedParticle">FTSelectedJets </parameter>
</processor>

 <processor name="MyFlavourTagInputsProcessor" type="FlavourTagInputsProcessor">
 <!--FlavourTagInputsProcessor - takes a set of vertices as a decay chain with its associated jet and calculates flavour tag inputs stroring them in the Jet RP's pid-->
  <!--Cut on the minimum momentum if track hits LayersHit-->
  <!--parameter name="AllLayersMomentumCut" type="double">1 </parameter-->
  <!--Cut on the minimum momentum if track hits LayersHit minus one-->
  <!--parameter name="AllbutOneLayersMomentumCut" type="double">2 </parameter-->
  <!--Name of the ReconstructedParticle collection that represents decay chains-->
  <parameter name="DecayChainRPCollection" type="string" lcioInType="ReconstructedParticle">DecayChains </parameter>
  <!--Name of the LCFloatVec Collection that will be created to contain the flavour tag inputs-->
  <parameter name="FlavourTagInputsCollection" type="string" lcioOutType="LCFloatVec">FlavourTagInputs </parameter>
  <!--Name of the Vertex collection that contains the primary vertex (Optional)-->
  <parameter name="IPVertexCollection" type="string" lcioInType="Vertex">IPVertex </parameter>
  <!--Upper Cut on the maximum value of d0 significance-->
  <!--parameter name="JProbMaxD0Significance" type="double">200 </parameter-->
  <!--Upper Cut on the maximum value of d0 and of z0-->
  <!--parameter name="JProbMaxD0andZ0" type="double">5 </parameter-->
  <!--Standard deviations of the impact parameters in RPhi plane-->
  <!--parameter name="JProbResolutionParameterRphi" type="FloatVec">1.01313 0.0246351 0.102198 0.0411203 0.0157711  </parameter-->
  <!--Standard deviations of the impact parameters in Z direction-->
  <!--parameter name="JProbResolutionParameterZ" type="FloatVec">1.0163 0.0271387 0.0948112 0.0410759 0.0148686  </parameter-->
  <!--Name of the ReconstructedParticle collection that represents jets-->
  <parameter name="JetRPCollection" type="string" lcioInType="ReconstructedParticle">Jets </parameter>
  <!--Momentum cuts will be applied on number of LayersHit and LayersHit minus one-->
  <!--parameter name="LayersHit" type="double">5 </parameter-->
  <!--Cut on the Chi squared of the two tracks beinig in the same vertex.-->
  <!--parameter name="PIDChi2Cut" type="double">6.63 </parameter-->
  <!--Cut on the upper limit of the photon candidate mass-->
  <!--parameter name="PIDMaxGammaMass" type="double">0.02 </parameter-->
  <!--Cut on the upper limit of the Ks candidate mass-->
  <!--parameter name="PIDMaxKsMass" type="double">0.525 </parameter-->
  <!--Cut on the lower limit of the Ks candidate mass-->
  <!--parameter name="PIDMinKsMass" type="double">0.475 </parameter-->
  <!--Cut on the maximum RPhi of the Ks/gamma decay vertex candidate-->
  <!--parameter name="PIDRPhiCut" type="double">20 </parameter-->
  <!--Cut on the minimum RPhi significance of the tracks-->
  <!--parameter name="PIDSignificanceCut" type="double">3 </parameter-->
  <!--Cut on the minimum number of tracks in the seed vertex.-->
  <!--parameter name="SecondVertexNtrackscut" type="double">1 </parameter-->
  <!--Cut on the Chi Squared of the seed vertex-->
  <!--parameter name="SecondVertexProbChisquarecut" type="double">20 </parameter-->
  <!--Parameter determining whether all tracks from secondary are included in the track attachment-->
  <!--parameter name="TrackAttachAllSecondaryTracks" type="bool">false </parameter-->
  <!--Upper cut on track distance of closest approach to the seed axis for the track attachment-->
  <!--parameter name="TrackAttachCloseapproachCut" type="double">1 </parameter-->
  <!--Cut determining the maximum L/D for the track attachment-->
  <!--parameter name="TrackAttachLoDCutmax" type="double">2.5 </parameter-->
  <!--Cut determining the minimum L/D for the track attachment-->
  <!--parameter name="TrackAttachLoDCutmin" type="double">0.18 </parameter-->
  <!--Maximum Sigma (based on error matrix) that the vertex axis can move when kinematic correction is applied-->
  <!--parameter name="VertexMassMaxKinematicCorrectionSigma" type="double">2 </parameter-->
  <!--Upper cut on angle between momentum of vertex and the vertex axis-->
  <!--parameter name="VertexMassMaxMomentumAngle" type="double">3 </parameter-->
  <!--Maximum factor, by which vertex mass can be corrected-->
  <!--parameter name="VertexMassMaxMomentumCorrection" type="double">2 </parameter-->
</processor>

 <processor name="MyFox" type="Fox">
 <!--Fox calculates Fox-Wolfram moments-->
  <!--Numbers of the moments that are to be calculate 0-th is calculate by default-->
  <parameter name="CalculateFoxWolframMoments" type="IntVec"> </parameter>
  <!--Name of the ReconstructedParticle collection-->
  <parameter name="NameOfReconstructedParticlesCollection" type="string" lcioInType="ReconstructedParticle">RecoParticles </parameter>
</processor>

 <processor name="MyFullLDCTracking" type="FullLDCTracking">
 <!--Performs full tracking in LDC detector-->
  <!--Cut on Opening Angle for forced merging of Si and TPC segments-->
  <parameter name="AngleCutForForcedMerging" type="float">0.05 </parameter>
  <!--Cut on Opening Angle for merging Si and TPC segments-->
  <parameter name="AngleCutForMerging" type="float">0.1 </parameter>
  <!--Assign ETD Hits-->
  <parameter name="AssignETDHits" type="int">1 </parameter>
  <!--Assign left over FTD hits-->
  <parameter name="AssignFTDHits" type="int">1 </parameter>
  <!--Assign SET Hits-->
  <parameter name="AssignSETHits" type="int">1 </parameter>
  <!--Assign left over SIT hits-->
  <parameter name="AssignSITHits" type="int">1 </parameter>
  <!--Assign left over TPC hits-->
  <parameter name="AssignTPCHits" type="int">1 </parameter>
  <!--Assign left over VTX hits-->
  <parameter name="AssignVTXHits" type="int">1 </parameter>
  <!--Cut on fit Chi2-->
  <parameter name="Chi2FitCut" type="float">100 </parameter>
  <!--Cut on fit Chi2-->
  <parameter name="Chi2PrefitCut" type="float">100000 </parameter>
  <!--Create Track to MCP Relations-->
  <parameter name="CreateMap" type="int">1 </parameter>
  <!--Cut on the number of the TPC hits for tracks with no Si hits-->
  <parameter name="CutOnTPCHits" type="int">35 </parameter>
  <!--Cut on the track parameter D0-->
  <parameter name="CutOnTrackD0" type="float">500 </parameter>
  <!--Cut on the track parameter Z0-->
  <parameter name="CutOnTrackZ0" type="float">500 </parameter>
  <!--Cut on D0 difference for forced merging of Si and TPC segments-->
  <parameter name="D0CutForForcedMerging" type="float">50 </parameter>
  <!--Cut on D0 difference for merging of Si and TPC segments-->
  <parameter name="D0CutForMerging" type="float">500 </parameter>
  <!--Cut on D0 difference for merging TPC segments-->
  <parameter name="D0CutToMergeTPCSegments" type="float">100 </parameter>
  <!--Activate debugging?-->
  <parameter name="Debug" type="int">0 </parameter>
  <!--Cut on dP/P difference for merging TPC segments-->
  <parameter name="DeltaPCutToMergeTPCSegments" type="float">0.1 </parameter>
  <!--ETD Hit Collection Name-->
  <parameter name="ETDHitCollection" type="string" lcioInType="TrackerHit">ETDTrackerHits </parameter>
  <!--Cut on distance between track and ETD hits-->
  <parameter name="ETDHitToTrackDistance" type="float">10 </parameter>
  <!--FTD Hit Collection Name-->
  <parameter name="FTDHitCollection" type="string" lcioInType="TrackerHit">FTDTrackerHits </parameter>
  <!--Cut on distance between track and FTD hits-->
  <parameter name="FTDHitToTrackDistance" type="float">2 </parameter>
  <!--Forbid overlap in Z for combining TPC segments with tracks having Si hits-->
  <parameter name="ForbidOverlapInZComb" type="int">0 </parameter>
  <!--Forbid overlap in Z for the merged TPC segments-->
  <parameter name="ForbidOverlapInZTPC" type="int">0 </parameter>
  <!--Force merging of Si and TPC segments?-->
  <parameter name="ForceSiTPCMerging" type="int">0 </parameter>
  <!--Force merging of TPC Segments?-->
  <parameter name="ForceTPCSegmentsMerging" type="int">1 </parameter>
  <!--LDC track collection name-->
  <parameter name="LDCTrackCollection" type="string" lcioOutType="Track">LDCTracks </parameter>
  <!--Collection name for the LDC track to MCParticle relations-->
  <parameter name="LDCTrackMCPRelCollection" type="string" lcioOutType="LCRelation">LDCTracksMCP </parameter>
  <!--number of hits for outward extrapolation-->
  <parameter name="NHitsExtrapolation" type="int">35 </parameter>
  <!--Cut on Omega difference for forced merging of Si and TPC segments-->
  <parameter name="OmegaCutForForcedMerging" type="float">0.15 </parameter>
  <!--Cut on Omega difference for merging Si and TPC segments-->
  <parameter name="OmegaCutForMerging" type="float">0.25 </parameter>
  <!--Option for the LDC Track fit-->
  <parameter name="OptFit" type="int">4 </parameter>
  <!--Option for Si tracks refitting-->
  <parameter name="OptFitSi" type="int">2 </parameter>
  <!--Option for TPC tracks refitting-->
  <parameter name="OptFitTPC" type="int">2 </parameter>
  <!--Cut on Pt of tracks for merging TPC segments-->
  <parameter name="PtCutToMergeTPCSegments" type="float">1.2 </parameter>
  <!--Refitted TPC track collection name-->
  <parameter name="ReffitedTPCTrackCollection" type="string" lcioOutType="Track">RefittedTPCTracks </parameter>
  <!--Refit Si Tracks ?-->
  <parameter name="RefitSiTracks" type="int">0 </parameter>
  <!--Refit TPC Tracks ?-->
  <parameter name="RefitTPCTracks" type="int">1 </parameter>
  <!--Refitted Si track collection name-->
  <parameter name="RefittedSiTrackCollection" type="string" lcioOutType="Track">RefittedSiTracks </parameter>
  <!--Collection name for the refittedSi track to MCParticle relations-->
  <parameter name="RefittedSiTrackMCPRelCollection" type="string" lcioOutType="LCRelation">RefittedSiTracksMCP </parameter>
  <!--Collection name for the refitted TPC track to MCParticle relations-->
  <parameter name="RefittedTPCTrackMCPRelCollection" type="string" lcioOutType="LCRelation">RefittedTPCTracksMCP </parameter>
  <!--SET Hit Collection Name-->
  <parameter name="SETHitCollection" type="string" lcioInType="TrackerHit">SETTrackerHits </parameter>
  <!--Cut on distance between track and SET hits-->
  <parameter name="SETHitToTrackDistance" type="float">2 </parameter>
  <!--SIT Hit Collection Name-->
  <parameter name="SITHitCollection" type="string" lcioInType="TrackerHit">SITTrackerHits </parameter>
  <!--Cut on distance between track and SIT hits-->
  <parameter name="SITHitToTrackDistance" type="float">2 </parameter>
  <!--Si Track Collection-->
  <parameter name="SiTracks" type="string" lcioInType="Track">SiTracks </parameter>
  <!--Si Track to Collection-->
  <parameter name="SiTracksMCPRelColl" type="string" lcioInType="LCRelation">SiTracksMCP </parameter>
  <!--Store only hits used in fit?-->
  <parameter name="StoreHitsInFit" type="int">0 </parameter>
  <!--Store Refitted Si Tracks ?-->
  <parameter name="StoreRefittedSiTracks" type="int">0 </parameter>
  <!--Store Refitted TPC Tracks ?-->
  <parameter name="StoreRefittedTPCTracks" type="int">0 </parameter>
  <!--TPC Hit Collection Name-->
  <parameter name="TPCHitCollection" type="string" lcioInType="TrackerHit">TPCTrackerHits </parameter>
  <!--Cut on distance between track and TPC hits-->
  <parameter name="TPCHitToTrackDistance" type="float">15 </parameter>
  <!--TPC Track Collection-->
  <parameter name="TPCTracks" type="string" lcioInType="Track">TPCTracks </parameter>
  <!--TPC Track to MCP Relation Collection Name-->
  <parameter name="TPCTracksMCPRelColl" type="string" lcioInType="LCRelation">TPCTracksMCP </parameter>
  <!--Use Extra Point in Fit-->
  <parameter name="UseExtraPoint" type="int">0 </parameter>
  <!--VTX Hit Collection Name-->
  <parameter name="VTXHitCollection" type="string" lcioInType="TrackerHit">VTXTrackerHits </parameter>
  <!--Cut on distance between track and VTX hits-->
  <parameter name="VTXHitToTrackDistance" type="float">1.5 </parameter>
  <!--Cut on Z0 difference for forced merging of Si and TPC segments-->
  <parameter name="Z0CutForForcedMerging" type="float">200 </parameter>
  <!--Cut on Z0 difference for merging of Si and TPC segments-->
  <parameter name="Z0CutForMerging" type="float">1000 </parameter>
  <!--Cut on Z0 difference for merging TPC segments-->
  <parameter name="Z0CutToMergeTPCSegments" type="float">5000 </parameter>
  <!--Parameter a to define minimal IP error-->
  <parameter name="aParameterForIPError" type="float">0.002 </parameter>
  <!--Parameter b to define minimal IP error-->
  <parameter name="bParameterForIPError" type="float">0.0076 </parameter>
  <!--Cut on cos theta between the two momentum vectors when considering merger of high Pt tracks-->
  <parameter name="cosThetaCutHighPtMerge" type="float">0.99 </parameter>
  <!--cut on cos theta between the two momentum vectors when considering merger of high Pt tracks for softer dp/p cut-->
  <parameter name="cosThetaCutSoftHighPtMerge" type="float">0.998 </parameter>
  <!--cut on 3D distance between hit and helix extrapolation when considering merger of high Pt tracks-->
  <parameter name="hitDistanceCutHighPtMerge" type="float">25 </parameter>
  <!--cut on maximum fraction of outliers when considering merger of high Pt tracks-->
  <parameter name="maxFractionOfOutliersCutHighPtMerge" type="float">0.95 </parameter>
  <!--cut for max 3D distance between any hit and helix extrapolation when considering merger of high Pt tracks-->
  <parameter name="maxHitDistanceCutHighPtMerge" type="float">50 </parameter>
  <!--cut on dp/p when considering merger of high Pt tracks-->
  <parameter name="momDiffCutHighPtMerge" type="float">0.01 </parameter>
  <!--softer cut on dp/p when considering merger of high Pt tracks-->
  <parameter name="momDiffCutSoftHighPtMerge" type="float">0.25 </parameter>
  <!--Parameter s to define minimal IP error-->
  <parameter name="sParameterForIPError" type="float">0.75 </parameter>
</processor>

 <processor name="MyGEMProcessor" type="GEMProcessor">
 <!--GEMProcessor makes Amplification in GEMs-->
  <!--Value of Induction Field-->
  <parameter name="EInd" type="float">5000 </parameter>
  <!--Value of Transfer Field 1-->
  <parameter name="ETrans1" type="float">2500 </parameter>
  <!--Value of Transfer Field 2-->
  <parameter name="ETrans2" type="float">2500 </parameter>
  <!--Correction Factor for Gain-->
  <parameter name="GainFactor" type="float">1 </parameter>
  <!--Name of the Input collection with drifted electrons-->
  <parameter name="InputCollectionName" type="string" lcioInType="SimTrackerHit">DriftedElectrons </parameter>
  <!--Name of the Output GEM collection-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="SimTrackerHit">AmplifiedElectrons </parameter>
  <!--Name of the File containing Parametrisation of GEMs-->
  <parameter name="ParamFile" type="string">parameterfile </parameter>
  <!--switch off writing of output collection-->
  <parameter name="Transient" type="int">0 </parameter>
  <!--Voltage on GEM 1-->
  <parameter name="UGEM1" type="float">315 </parameter>
  <!--Voltage on GEM 2-->
  <parameter name="UGEM2" type="float">315 </parameter>
  <!--Voltage on GEM 3-->
  <parameter name="UGEM3" type="float">315 </parameter>
</processor>

 <processor name="MyGainCorrectorProcessor" type="GainCorrectorProcessor">
 <!--GainCorrectorProcessor converts FADC counts into primary electrons, assumes a linear gain (needing no corrections), provided via LCCD-->
  <!--Name of the collection containing the channel corrections-->
  <!--parameter name="ChannelCorrectionCollection" type="string">TPCChannelCorrection </parameter-->
  <!--Name of the input collection as stored in the LCIO file-->
  <parameter name="InputTrackerPulses" type="string" lcioInType="TrackerData">TPCPulses </parameter>
  <!--Name of the collection to be stored in the LCIO file-->
  <parameter name="OutputTrackerPulses" type="string" lcioOutType="TrackerData">TPCPulses </parameter>
  <!--if not 0 the output collection is set transient-->
  <!--parameter name="SetOutputTransient" type="bool">true </parameter-->
  <!--Name of the collection containing the TPC conditions-->
  <!--parameter name="TPCConditionsCollection" type="string">TPCConditions </parameter-->
</processor>

 <processor name="MyGenericViewer" type="GenericViewer">
 <!--Drawing Utility-->
  <!--Calo Hit Collection Names-->
  <parameter name="CaloHitCollections" type="StringVec" lcioInType="CalorimeterHit">ECAL HCAL  </parameter>
  <!--Cluster Collection Name-->
  <parameter name="ClusterCollection" type="string" lcioInType="Cluster">ClustersAR </parameter>
  <!--Detector Model-->
  <parameter name="DetectorModel" type="int">0 </parameter>
  <!--Layer for Calo Hits-->
  <parameter name="LayerCaloHit" type="int">-1 </parameter>
  <!--Layer for Reco Clusters-->
  <parameter name="LayerClusters" type="int">-1 </parameter>
  <!--Layer for Reco Particles-->
  <parameter name="LayerReco" type="int">9 </parameter>
  <!--Layer for Sim Calo Hits-->
  <parameter name="LayerSimCaloHit" type="int">-1 </parameter>
  <!--Layer for Sim Tracker Hits-->
  <parameter name="LayerSimTrackerHit" type="int">-1 </parameter>
  <!--Layer for Tracker Hits-->
  <parameter name="LayerTrackerHit" type="int">-1 </parameter>
  <!--Layer for Tracks-->
  <parameter name="LayerTracks" type="int">-1 </parameter>
  <!--Layer for True Clusters-->
  <parameter name="LayerTrueClusters" type="int">-1 </parameter>
  <!--Layer for True Tracks-->
  <parameter name="LayerTrueTracks" type="int">-1 </parameter>
  <!--Magnetic Field-->
  <parameter name="MagneticField" type="float">4 </parameter>
  <!--Particle Collection Name-->
  <parameter name="ParticleCollection" type="string" lcioInType="ReconstructedParticle">RecoParticles </parameter>
  <!--Sim Calo Hit Collection Names-->
  <parameter name="SimCaloHitCollections" type="StringVec" lcioInType="SimCalorimeterHit">ecal02_EcalBarrel ecal02_EcalEndcap hcalFeRPC1_HcalBarrelEnd hcalFeRPC1_HcalBarrelReg hcalFeRPC1_HcalEndCaps  </parameter>
  <!--Sim Tracker Hit Collection Names-->
  <parameter name="SimTrackerHitCollections" type="StringVec" lcioInType="SimTrackerHit">tpc03_TPC  </parameter>
  <!--Track Collection Name-->
  <parameter name="TrackCollection" type="string" lcioInType="Track">TPC_Tracks </parameter>
  <!--Tracker Hit Collection Names-->
  <parameter name="TrackerHitCollections" type="StringVec" lcioInType="TrackerHit">TPCTrackerHits  </parameter>
  <!--True Cluster Collection Name-->
  <parameter name="TrueClusterCollection" type="string" lcioInType="Cluster">TrueClusters </parameter>
  <!--True Track Collection Name-->
  <parameter name="TrueTrackCollection" type="string" lcioInType="Track">TrueTracks </parameter>
  <!--Wait for Keyboard before proceed-->
  <parameter name="WaitForKeyboard" type="int">1 </parameter>
</processor>

 <processor name="MyHEP_RecordProcessor" type="HEP_RecordProcessor">
 <!--HEP record balance and drawing-->
</processor>

 <processor name="MyHitAndTrackChargeProcessor" type="HitAndTrackChargeProcessor">
 <!--Count hits in events and tracks, and track per event-->
  <!--Name of the input hits collection (default: TPCHits)-->
  <parameter name="InputHits" type="string" lcioInType="TrackerHit">TPCHits </parameter>
  <!--Name of the input tracks collection (default: TPCTracks)-->
  <parameter name="InputTracks" type="string" lcioInType="Track">TPCTracks </parameter>
  <!--Maximum value in ChargePerHit histograms (default: ?? )-->
  <parameter name="MaxChargePerHit" type="float">10000 </parameter>
  <!--MaxChargePerTrack Maximum value in ChargePerHit histogram (default: ?? )-->
  <parameter name="MaxChargePerTrack" type="float">100000 </parameter>
  <!--MaxZ Maximum z value of highest bin in case of z binning (default: 260)-->
  <parameter name="MaxZ" type="float">260 </parameter>
  <!--Max_dEdx  Maximum value in dEdx histogram (default: ?? )-->
  <parameter name="Max_dEdx" type="float">1000 </parameter>
  <!--MinZ Minimum z value of lowest bin in case of z binning (default: 0)-->
  <parameter name="MinZ" type="float">0 </parameter>
  <!--Number ob bins in z, 0 means one Histo without z cut (default: 10)-->
  <parameter name="nZBins" type="int">10 </parameter>
</processor>

 <processor name="MyHitAndTrackCounterProcessor" type="HitAndTrackCounterProcessor">
 <!--Count hits in events and tracks, and track per event-->
  <!--Name of the input hits collection (default: TPCHits)-->
  <parameter name="InputHits" type="string" lcioInType="TrackerHit">TPCHits </parameter>
  <!--Name of the input tracks collection (default: TPCTracks)-->
  <parameter name="InputTracks" type="string" lcioInType="Track">TPCTracks </parameter>
  <!--Maximum value in HitsPerEvent  histogram (default: 50 )-->
  <parameter name="MaxHitsPerEvent" type="int">50 </parameter>
  <!--Maximum value in HitsPerTrack  histogram (default: 20 )-->
  <parameter name="MaxHitsPerTrack" type="int">20 </parameter>
  <!--Maximum value in TracksPerEvent  histogram (default: 10 )-->
  <parameter name="MaxTracksPerEvent" type="int">10 </parameter>
</processor>

 <processor name="MyHitTrackFinderTopoProcessor" type="HitTrackFinderTopoProcessor">
 <!--HitTrackFinderTopoProcessor calculates TrackerHits from TrackerPulses-->
  <!--Optional: Name of the input collection containing the TPC conditions data-->
  <!--parameter name="InputTPCConditions" type="string">TPCConditions </parameter-->
  <!--Name of the input TrackerPulses collection-->
  <parameter name="InputTrackerPulses" type="string" lcioInType="TrackerPulse">TPCPulses </parameter>
  <!--Maximum number of empty consecuitve pads in hit (default: 1)-->
  <parameter name="MaxEmptyPads" type="int">1 </parameter>
  <!--Maximum number of subsequnetly missing hits (default: 1)-->
  <parameter name="MaxSkipRows" type="int">1 </parameter>
  <!--Maximum time between pulses in a hit in ns (default: 200.)-->
  <parameter name="MaxTimeSpread" type="float">200 </parameter>
  <!--Minimum size of hit / Minimum number of Pads (default: 1)-->
  <parameter name="MinHitSize" type="int">1 </parameter>
  <!--Minimum number of hits on track (default: 5)-->
  <parameter name="MinTrackHits" type="int">5 </parameter>
  <!--Set to 1 for the second half TPC, which look into the negative z direction (default: 0)-->
  <parameter name="NegativeZDirection" type="int">0 </parameter>
  <!--Name of the output Tracks collection-->
  <parameter name="OutputTrackCandidates" type="string" lcioOutType="Track">TPCTrackCandidates </parameter>
  <!--Name of the output TrackerHits collection-->
  <parameter name="OutputTrackerHits" type="string" lcioOutType="TrackerHit">TPCHits </parameter>
  <!--if not 0 the output hits collection is set transient (default: 0)-->
  <parameter name="SetOutputHitsTransient" type="int">0 </parameter>
  <!--if not 0 the output trackscollection is set transient (default: 0)-->
  <parameter name="SetOutputTrackCandidatesTransient" type="int">0 </parameter>
  <!--Optional: Set drift velocity in case there is no conditions data in mm/us-->
  <!--parameter name="VDrift" type="float">0 </parameter-->
</processor>

 <processor name="MyInhEFieldCalculationProcessor" type="InhEFieldCalculationProcessor">
 <!--InhEFieldCalculationProcessor maps charge to padplane ...-->
  <!--Name of the Input collection with drifted electrons-->
  <parameter name="InputCollectionName" type="string" lcioInType="LCGenericObject">IonOccupancy </parameter>
  <!--Name of the Output GEM collection-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="LCGenericObject">InhEFieldMap </parameter>
  <!--switch off writing of output collection-->
  <parameter name="Transient" type="int">0 </parameter>
  <!--Number of bins in x direction-->
  <parameter name="xBins" type="int">2 </parameter>
  <!--Number of bins in y direction-->
  <parameter name="yBins" type="int">2 </parameter>
  <!--Number of bins in z -->
  <parameter name="zBins" type="int">2 </parameter>
</processor>

 <processor name="MyIonBackDriftProcessor" type="IonBackDriftProcessor">
 <!--IonBackDriftProcessor gives coordinates of ions escaping GEM structure.-->
  <!--Value of the Drift Field-->
  <parameter name="DriftField" type="double">240 </parameter>
  <!--Value of Induction Field-->
  <parameter name="EInd" type="double">5000 </parameter>
  <!--Value of Transfer Field 1-->
  <parameter name="ETrans1" type="double">2500 </parameter>
  <!--Value of Transfer Field 2-->
  <parameter name="ETrans2" type="double">2500 </parameter>
  <!--Name of the input collection with amplified electrons-->
  <parameter name="InputCollectionName" type="string" lcioInType="LCGenericObject">DistributedElectrons </parameter>
  <!--Name of the output collection with backdrifting ions-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="LCGenericObject">BackdriftingIons </parameter>
  <!--Name of the File containing Parametrisation of GEMs-->
  <parameter name="ParamFile" type="string">parameterfile </parameter>
  <!--switch off writing of output collection-->
  <parameter name="Transient" type="int">0 </parameter>
  <!--Voltage on GEM 1-->
  <parameter name="UGEM1" type="double">315 </parameter>
  <!--Voltage on GEM 2-->
  <parameter name="UGEM2" type="double">315 </parameter>
  <!--Voltage on GEM 3-->
  <parameter name="UGEM3" type="double">315 </parameter>
</processor>

 <processor name="MyIonsInVoxelsProcessor" type="IonsInVoxelsProcessor">
 <!--IonsInVoxelsProcessor puts primary ions in voxels...-->
  <!--Length of a z bin-->
  <parameter name="BinLength" type="double">2.5 </parameter>
  <!--e- from PrimaryIonisation-->
  <parameter name="InputCollectionName" type="string" lcioInType="SimTrackerHit">PrimaryIonisation </parameter>
  <!--Name of the Output GEM collection-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="LCGenericObject">IonOccupancy </parameter>
  <!--switch off writing of output collection-->
  <parameter name="Transient" type="int">0 </parameter>
</processor>

 <processor name="MyJoinEvents" type="JoinEvents">
 <!--Opens an lcio file and adds all collections of the corresponding (run/event-number) events to the current event.-->
  <!--post fix appended to all collection names-->
  <!--parameter name="ColNamePostFix" type="string">_1 </parameter-->
  <!--Name of the lcio input file-->
  <parameter name="InputFileName" type="string">joinevents.slcio </parameter>
</processor>

 <processor name="MyKIT" type="KIT">
 <!--KIT does whatever it does ...-->
  <!--To do the cleaning on hits or not -->
  <parameter name="Cleaning" type="string">YES </parameter>
  <!--Name of the Cluster Collection for Cores -->
  <parameter name="Core_Collection" type="string">CORE </parameter>
  <!--Cosine of the angle for merging -->
  <parameter name="Coscut" type="double">0.95 </parameter>
  <!--Square of distance cut for merging -->
  <parameter name="Distcut" type="double">35 </parameter>
  <!--Name of the CalorimeterHit Collection for ECAL -->
  <parameter name="ECAL_Collection" type="string">ECAL </parameter>
  <!--Levels for central loop in MIP -->
  <parameter name="Levels" type="FloatVec">0.1 1.5 2.5 4 6 9 16 26 41 65  </parameter>
  <!--Minimal Number of hits for ground level cluster -->
  <parameter name="MinHit0" type="int">4 </parameter>
  <!--Minimal Number of hits for i-th level cluster -->
  <parameter name="MinHitSplit" type="int">2 </parameter>
  <!--Number of levels for central loop -->
  <parameter name="NumberOfLevels" type="int">10 </parameter>
  <!--Fluctuation suprresion cut-->
  <parameter name="Rcut" type="double">0.4 </parameter>
  <!--At which number of neighbors to put the threshold, condition is < so you need to put N+1 -->
  <parameter name="TopologicalCut" type="int">5 </parameter>
</processor>

 <processor name="MyKnowYourInputs" type="KnowYourInputs">
 <!--KnowYourInputs processor evaluates hits+clusters+tracks-->
  <!--Enable CalorimeterHit diagnostics-->
  <!--parameter name="doCalorimeterHit" type="bool">true </parameter-->
  <!--Enable ReconstructedParticle diagnostics-->
  <!--parameter name="doReconstructedParticle" type="bool">true </parameter-->
  <!--Enable SimCalorimeterHit diagnostics-->
  <!--parameter name="doSimCalorimeterHit" type="bool">true </parameter-->
  <!--Enable SimTrackerHit diagnostics-->
  <!--parameter name="doSimTrackerHit" type="bool">true </parameter-->
  <!--Enable Track diagnostics-->
  <!--parameter name="doTrack" type="bool">true </parameter-->
  <!--Enable TrackerHit diagnostics-->
  <!--parameter name="doTrackerHit" type="bool">true </parameter-->
</processor>

 <processor name="MyLCFIAIDAPlotProcessor" type="LCFIAIDAPlotProcessor">
 <!--Creates an AIDA plot of the LCFIVertex tagging efficiency-purity values and various other things.  Make sure that MarlinAIDAProcessor is run before this.-->
  <!--Cut determining the Neural Net cut used to select B-Jets-->
  <!--parameter name="BTagNNCut" type="double">0.7 </parameter-->
  <!--Name of collection containing the vertex charge of the jets, assuming they are B-jets-->
  <!--parameter name="BVertexChargeCollection" type="string">BCharge </parameter-->
  <!--Cut determining the Neural Net cut used to select C-Jets-->
  <!--parameter name="CTagNNCut" type="double">0.7 </parameter-->
  <!--Name of collection containing the vertex charge of the jets, assuming they are C-jets-->
  <!--parameter name="CVertexChargeCollection" type="string">CCharge </parameter-->
  <!--Cut determining the maximum cos(theta) of the jet.  Default: |cos(theta)|<0.9-->
  <!--parameter name="CosThetaJetMax" type="double">0.9 </parameter-->
  <!--Cut determining the minimum cos(theta) of the jet.  Default: no lower cut.-->
  <!--parameter name="CosThetaJetMin" type="double">0 </parameter-->
  <!--Names of the LCFloatVec Collections that contain the flavour tags (one purity efficiency plot per tag) (in same order as jet collection)-->
  <parameter name="FlavourTagCollections" type="StringVec">FlavourTag  </parameter>
  <!--Name of the collection of ReconstructedParticles that is the jet-->
  <parameter name="JetCollectionName" type="string" lcioInType="ReconstructedParticle">FTSelectedJets </parameter>
  <!--Name of the collection that holds all MC particles. -->
  <parameter name="MCParticleCollection" type="string" lcioInType="MCParticle">MCParticlesSkimed </parameter>
  <!--Set true if you want to make all other plots (i.e. the non purity-efficiency plots) and the other functionality provided by LCFIAIDAPlotProcessor-->
  <!--parameter name="MakeAdditionalPlots" type="bool">false </parameter-->
  <!--Set true if you want to make the purity-efficiency plots, and leakage rates plots for the various flavour tags-->
  <!--parameter name="MakePurityEfficiencyPlots" type="bool">true </parameter-->
  <!--Set true to make a tuple of the flavour tag input variables.  Default is false (only works with jaida).-->
  <!--parameter name="MakeTuple" type="bool">false </parameter-->
  <!--Cut determining the maximum momentum of the jet.  Default: 10000 GeV/c-->
  <!--parameter name="PJetMax" type="double">10000 </parameter-->
  <!--Cut determining the minimum momentum of the jet.  Default: no lower cut.-->
  <!--parameter name="PJetMin" type="double">0 </parameter-->
  <!--Set true if you want a print-out of the purity-efficiency for the various flavour tags-->
  <!--parameter name="PrintPurityEfficiencyValues" type="bool">true </parameter-->
  <!--Set true if you want a print-out of the track-vertex association purity-->
  <!--parameter name="PrintTrackVertexOutput" type="bool">false </parameter-->
  <!--Output filename for the Purity-Efficiency values.  Only used if PrintPurityEfficiencyValues parameter is true.  If left blank, output will be directed to standard out.-->
  <!--parameter name="PurityEfficiencyOutputFile" type="string">PurityEfficiencyOutput.txt </parameter-->
  <!--Names of the LCFloatVec Collections that contain the flavour tag inputs (in same order as jet collection)-->
  <parameter name="TagInputsCollections" type="StringVec">FlavourTagInputs  </parameter>
  <!--Output filename for the table of the Track-Vertex association.  Only used if PrintTrackVertexOutput parameter is true.  If left blank, output will be directed to standard out.-->
  <!--parameter name="TrackVertexOutputFile" type="string">TrackVertexOutput.txt </parameter-->
  <!--Name of the LCFloatVec collection containing the true flavour of the jets (same order as jets)-->
  <!--parameter name="TrueJetFlavourCollection" type="string">TrueJetFlavour </parameter-->
  <!--Name of collection linking the tracks and the Monte Carlo Particles-->
  <!--parameter name="TrueTracksToMCPCollection" type="string">LDCTracksMCP </parameter-->
  <!--Integer parameter determing which FlavourTag Collection to use the determine C-Jets and B-Jets in Vertex Charge Plots-->
  <!--parameter name="UseFlavourTagCollectionForVertexCharge" type="int">0 </parameter-->
  <!--Name of the collection that holds the Vertices-->
  <!--parameter name="VertexCollection" type="string">ZVRESVertices </parameter-->
  <!--Name of the ZVRES DecayChain collection-->
  <!--parameter name="ZVRESDecayChainCollection" type="string">ZVRESDecayChains </parameter-->
  <!--Name of the ZVRES Decay Chain Tracks Collection-->
  <!--parameter name="ZVRESDecayChainTrackCollection" type="string">ZVRESDecayChainRPTracks </parameter-->
  <!--Name of the ZVRES Selected Jets collection-->
  <!--parameter name="ZVRESSelectedJetsCollection" type="string">ZVRESSelectedJets </parameter-->
</processor>

 <processor name="MyLCIOOutputProcessor" type="LCIOOutputProcessor">
 <!--Writes the current event to the specified LCIO outputfile. Needs to be the last ActiveProcessor.-->
  <!--drops the named collections from the event-->
  <!--parameter name="DropCollectionNames" type="StringVec">TPCHits HCalHits  </parameter-->
  <!--drops all collections of the given type from the event-->
  <!--parameter name="DropCollectionTypes" type="StringVec">SimTrackerHit SimCalorimeterHit  </parameter-->
  <!-- write complete objects in subset collections to the file (i.e. ignore subset flag)-->
  <!--parameter name="FullSubsetCollections" type="StringVec">MCParticlesSkimmed  </parameter-->
  <!--force keep of the named collections - overrules DropCollectionTypes (and DropCollectionNames)-->
  <!--parameter name="KeepCollectionNames" type="StringVec">MyPreciousSimTrackerHits  </parameter-->
  <!-- name of output file -->
  <parameter name="LCIOOutputFile" type="string">outputfile.slcio </parameter>
  <!--write mode for output file:  WRITE_APPEND or WRITE_NEW-->
  <parameter name="LCIOWriteMode" type="string">None </parameter>
  <!--will split output file if size in kB exceeds given value - doesn't work with APPEND and NEW-->
  <!--parameter name="SplitFileSizekB" type="int">1992294 </parameter-->
</processor>

 <processor name="MyLDCCaloDigi" type="LDCCaloDigi">
 <!--Performs simple digitization of sim calo hits...-->
  <!--Calibration coefficients for ECAL-->
  <parameter name="CalibrECAL" type="FloatVec">40.91 81.81  </parameter>
  <!--Calibration coefficients for HCAL-->
  <parameter name="CalibrHCAL" type="FloatVec">34.8  </parameter>
  <!--ECAL Collection Names-->
  <parameter name="ECALCollections" type="StringVec" lcioInType="SimCalorimeterHit">EcalBarrelCollection EcalEndcapCollection EcalRingCollection  </parameter>
  <!--Correct for ECAL gaps-->
  <parameter name="ECALGapCorrection" type="int">1 </parameter>
  <!--Factor applied to gap correction-->
  <parameter name="ECALGapCorrectionFactor" type="float">1 </parameter>
  <!--Index of ECal Layers-->
  <parameter name="ECALLayers" type="IntVec">20 100  </parameter>
  <!--Factor applied to module gap correction-->
  <parameter name="ECALModuleGapCorrectionFactor" type="float">0.5 </parameter>
  <!--ECAL Collection of real Hits-->
  <parameter name="ECALOutputCollection" type="string" lcioOutType="CalorimeterHit">ECAL </parameter>
  <!--Threshold for ECAL Hits in GeV-->
  <parameter name="ECALThreshold" type="float">5e-05 </parameter>
  <!--Energy correction for endcap-->
  <parameter name="ECAlEndcapCorrectionFactor" type="float">1.025 </parameter>
  <!--HCAL Collection Names-->
  <parameter name="HCALCollections" type="StringVec" lcioInType="SimCalorimeterHit">HcalBarrelRegCollection HcalEndcapRingsCollection HcalEndcapsCollection  </parameter>
  <!--Index of HCal Layers-->
  <parameter name="HCALLayers" type="IntVec">100  </parameter>
  <!--HCAL Collection of real Hits-->
  <parameter name="HCALOutputCollection" type="string" lcioOutType="CalorimeterHit">HCAL </parameter>
  <!--Threshold for HCAL Hits in GeV-->
  <parameter name="HCALThreshold" type="float">0.00025 </parameter>
  <!--Digital Ecal-->
  <parameter name="IfDigitalEcal" type="int">0 </parameter>
  <!--Digital Hcal-->
  <parameter name="IfDigitalHcal" type="int">0 </parameter>
  <!--CaloHit Relation Collection-->
  <parameter name="RelationOutputCollection" type="string" lcioOutType="LCRelation">RelationCaloHit </parameter>
</processor>

 <processor name="MyLEPTrackingProcessor" type="LEPTrackingProcessor">
 <!--Produces Track collection from TPC TrackerHit collections using LEP tracking algorithms-->
  <!--No attempt will be made to run without CurlKiller functionallity-->
  <parameter name="AlwaysRunCurlKiller" type="int">0 </parameter>
  <!--Bin Height in pad multiples-->
  <parameter name="BinHeight" type="int">1 </parameter>
  <!--Bin Width in pad multiples-->
  <parameter name="BinWidth" type="int">3 </parameter>
  <!--Name of the TrackerHit collection NOT used in PATREC-->
  <parameter name="DroppedCollectionName" type="string" lcioOutType="TrackerHit">DroppedTPCTrackeHits </parameter>
  <!--Name of the TPC Track MC Relation collection-->
  <parameter name="MCTPCTrackRelCollectionName" type="string" lcioOutType="LCRelation">TPCTracksMCP </parameter>
  <!--Cut on the number of hits in r-phi bin-->
  <parameter name="MultiplicityCut" type="int">8 </parameter>
  <!--Name of the TPC Track collection-->
  <parameter name="TPCTrackCollectionName" type="string" lcioOutType="Track">TPCTracks </parameter>
  <!--Name of the TPC TrackerHit collection-->
  <parameter name="TPCTrackerHitCollectionName" type="string" lcioInType="TrackerHit">TPCTrackerHits </parameter>
  <!--Name of the TrackerHit collection used in PATREC-->
  <parameter name="UsedCollectionName" type="string" lcioOutType="TrackerHit">UsedTPCTrackerHits </parameter>
</processor>

 <processor name="MyLinearGeometricMeanResolutionProcessor" type="LinearGeometricMeanResolutionProcessor">
 <!--LinearGeometricMeanResolutionProcessor determines the resolution via the geometric mean method-->
  <!--Flag whether to cut in z , default 0-->
  <parameter name="ApplyZCut" type="int">0 </parameter>
  <!--Histograms will be binned with _histoBin, default _histoBin = 100-->
  <parameter name="HistoBin" type="int">100 </parameter>
  <!--Name of the histogramm with all hits in the track fit , default: histoGeoN-->
  <parameter name="HistoGeoNName" type="string">histoGeoN </parameter>
  <!--Name of the histogramm with n -1 hits in the track fit , default: histoGeoNminus1-->
  <parameter name="HistoGeoNminus1Name" type="string">histoGeoNminus1 </parameter>
  <!--Histograms will have range (-_histoRange, _histoRange), default _histoRange = 1mm-->
  <parameter name="HistoRange" type="float">1 </parameter>
  <!--Name of the input collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="Track">TimePixTracks </parameter>
  <!--Maximal z value, default 0 mm-->
  <parameter name="ZMax" type="float">100 </parameter>
  <!--Minimal z value, default 0 mm-->
  <parameter name="ZMin" type="float">0 </parameter>
</processor>

 <processor name="MyLinearRegressionProcessor" type="LinearRegressionProcessor">
 <!--Calculates seed track parameters from  in the TrackerHits in the track candidates collection!-->
  <!--The the name of the input collection of track candidates (default: TPCTrackCandidates)-->
  <parameter name="InputTrackCandidates" type="string" lcioInType="Track">TPCTrackCandidates </parameter>
  <!--The name of the collection the seed tracks be stored under (default: TPCSeedTracks)-->
  <parameter name="OutputSeedTracks" type="string" lcioOutType="Track">TPCSeedTracks </parameter>
  <!--if not 0 the output hits collection is set transient (default: 0)-->
  <parameter name="SetOutputTransient" type="int">0 </parameter>
</processor>

 <processor name="MyLinearThreePointResolutionProcessor" type="LinearThreePointResolutionProcessor">
 <!--LinearThreePointResolutionProcessor determines the 3 point resolution of a linear track-->
  <!--d3P values will be binned with _histoBin3P in each histgram, default _histoBin3P = 100-->
  <parameter name="HistoBin3P" type="int">100 </parameter>
  <!--histoNoTrack will be binned with _histoBinNoTrack and its range is (0,_histoBinNoTrack), default _histoBinNoTrack = 20-->
  <parameter name="HistoBinNoTrack" type="int">20 </parameter>
  <!--Time values will be binned with _histoBinTime in each histgram, default _histoBinTime = 16000-->
  <parameter name="HistoBinTime" type="int">16000 </parameter>
  <!--d3P will have range (-_histoRange3P, _histoRange3P) in each histogram, default _histoRange3P = 1 mm-->
  <parameter name="HistoRange3P" type="float">1 </parameter>
  <!--Time values will have range (0, _histoRangeTime) in each histgram, default _histoRangeTime = 16000 counts-->
  <parameter name="HistoRangeTime" type="float">16000 </parameter>
  <!--Name of the input collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="Track">TimePixTracks </parameter>
</processor>

 <processor name="MyMCTruthJetEnergy" type="MCTruthJetEnergy">
 <!--MCTruthJetEnergy calculates the MC truth jet energy of the MCParticles associated to the reconstructed particles in the jet-->
  <!--Names of the Jet collections-->
  <parameter name="JetCollectionNames" type="StringVec" lcioInType="ReconstructedParticle">FTSelected_2Jets FTSelected_3Jets FTSelected_4Jets FTSelected_5Jets FTSelected_6Jets  </parameter>
  <!--Name of the ReconstructedParticle-MCParticle  relation collection-->
  <parameter name="MCTruthRelationName" type="string" lcioInType="LCRelation">RecoMCTruthLink </parameter>
</processor>

 <processor name="MyMaterialDB" type="MaterialDB">
 <!--Material DB builder...-->
  <!--Build SET detector?-->
  <parameter name="BuildSET" type="int">1 </parameter>
  <!--Use Extrapolations in Fit-->
  <parameter name="UseExtrapolations" type="int">1 </parameter>
  <!--Use material database-->
  <parameter name="UseMaterials" type="int">1 </parameter>
</processor>

 <processor name="MyMokkaCaloDigi" type="MokkaCaloDigi">
 <!--Mokka digitizer...-->
  <!--Calibration coefficients for ECAL-->
  <parameter name="CalibrECAL" type="FloatVec">31.3 83  </parameter>
  <!--Calibration coefficients for HCAL-->
  <parameter name="CalibrHCAL" type="FloatVec">27.3  </parameter>
  <!--ECAL Collection Names-->
  <parameter name="ECALCollections" type="StringVec" lcioInType="SimCalorimeterHit">SEcal01_EcalEndcap SEcal01_EcalBarrel  </parameter>
  <!--Index of ECal Layers-->
  <parameter name="ECALLayers" type="IntVec">30 100  </parameter>
  <!--Threshold for ECAL Hits in GeV-->
  <parameter name="ECALThreshold" type="float">1e-04 </parameter>
  <!--HCAL Collection Names-->
  <parameter name="HCALCollections" type="StringVec" lcioInType="SimCalorimeterHit">SHcal01_HcalBarrelEnd SHcal01_HcalBarrelReg SHcal01_HcalEndCaps  </parameter>
  <!--Index of HCal Layers-->
  <parameter name="HCALLayers" type="IntVec">100  </parameter>
  <!--Threshold for HCAL Hits in GeV-->
  <parameter name="HCALThreshold" type="float">0.0004 </parameter>
  <!--Digital Ecal-->
  <parameter name="IfDigitalEcal" type="int">0 </parameter>
  <!--Digital Hcal-->
  <parameter name="IfDigitalHcal" type="int">0 </parameter>
  <!--name for the new collection of ECAL hits-->
  <parameter name="NewECALCollName" type="string" lcioOutType="CalorimeterHit">ECAL </parameter>
  <!--name for the new collection of HCAL hits-->
  <parameter name="NewHCALCollName" type="string" lcioOutType="CalorimeterHit">HCAL </parameter>
  <!--name for collection of relations between CalorimeterHits and SimCalorimeterHits-->
  <parameter name="RelationCollName" type="string" lcioOutType="LCRelation">RelationCaloHit </parameter>
</processor>

 <processor name="MyMyPFOAnalysis" type="MyPFOAnalysis">
 <!--MyPFOAnalysis analyses output of PandoraPFA-->
  <!--Cluster Collection Name -->
  <parameter name="ClusterCollectionName" type="string"> </parameter>
  <!--Run Confusion Analysis-->
  <parameter name="ConfusionAnalysis" type="int">0 </parameter>
  <!--Low qq cut-->
  <parameter name="CosQQCut" type="float">1.1 </parameter>
  <!--High E cut-->
  <parameter name="ECutHigh" type="float">0 </parameter>
  <!--Low E cut-->
  <parameter name="ECutLow" type="float">10000 </parameter>
  <!--Particle Collection Name -->
  <parameter name="ParticleCollectionName" type="string">PandoraPFOs </parameter>
  <!--Set the debig print level-->
  <parameter name="Printing" type="int">0 </parameter>
  <!--Draw the display-->
  <parameter name="RecoDisplay" type="int">0 </parameter>
  <!--Name of the calo hit <-> sim calo hit relation-->
  <parameter name="RelationCaloString" type="string">RelationCaloHit </parameter>
  <!--Name of the track hit <-> sim track hit relation-->
  <parameter name="RelationTrackString" type="string">TrueTracksMCP </parameter>
  <!--Name of the Track collection used for clustering-->
  <parameter name="RootFile" type="string">MyPFOAnalysis.root </parameter>
</processor>

 <processor name="MyNNClusterProcessor" type="NNClusterProcessor">
 <!--NNClusterProcessor : simple nearest neighbour clustering-->
  <!--Cut for distance between hits in mm-->
  <parameter name="DistanceCut" type="float">40 </parameter>
  <!--Cut for hit energy in GeV-->
  <parameter name="EnergyCut" type="float">0 </parameter>
  <!--Name of the input collections-->
  <parameter name="HitCollections" type="StringVec" lcioInType="CalorimeterHit">ecal  </parameter>
  <!--Name of the output collections-->
  <parameter name="OutputCollection" type="string" lcioOutType="Cluster">NNClusters </parameter>
</processor>

 <processor name="MyNeuralNetTrainer" type="NeuralNetTrainer">
 <!--Trains a neural net from the lcio file-->
  <!--Output filename for the trained net. If it is blank (default) then this net is not trained-->
  <parameter name="Filename-b_net-1vtx" type="string"> </parameter>
  <!--Output filename for the trained net. If it is blank (default) then this net is not trained-->
  <parameter name="Filename-b_net-2vtx" type="string"> </parameter>
  <!--Output filename for the trained net. If it is blank (default) then this net is not trained-->
  <parameter name="Filename-b_net-3plusvtx" type="string"> </parameter>
  <!--Output filename for the trained net. If it is blank (default) then this net is not trained-->
  <parameter name="Filename-bc_net-1vtx" type="string"> </parameter>
  <!--Output filename for the trained net. If it is blank (default) then this net is not trained-->
  <parameter name="Filename-bc_net-2vtx" type="string"> </parameter>
  <!--Output filename for the trained net. If it is blank (default) then this net is not trained-->
  <parameter name="Filename-bc_net-3plusvtx" type="string"> </parameter>
  <!--Output filename for the trained net. If it is blank (default) then this net is not trained-->
  <parameter name="Filename-c_net-1vtx" type="string"> </parameter>
  <!--Output filename for the trained net. If it is blank (default) then this net is not trained-->
  <parameter name="Filename-c_net-2vtx" type="string"> </parameter>
  <!--Output filename for the trained net. If it is blank (default) then this net is not trained-->
  <parameter name="Filename-c_net-3plusvtx" type="string"> </parameter>
  <!--Name of the LCFloatVec Collection that contains the flavour tag inputs (in same order as jet collection)-->
  <parameter name="FlavourTagInputsCollection" type="string" lcioInType="LCFloatVec">FlavourTagInputs </parameter>
  <!--Name of the collection of ReconstructedParticles that is the jet-->
  <parameter name="JetCollectionName" type="string" lcioInType="ReconstructedParticle">SGVJets </parameter>
  <!--Set this to 0 to output the neural nets in plain text format (default), or 1 (or anything non zero) to save in XML format-->
  <parameter name="SaveAsXML" type="int">0 </parameter>
  <!--Name of the LCIntVec Collection that contains the true jet flavours-->
  <parameter name="TrueJetFlavourCollection" type="string" lcioInType="LCFloatVec">TrueJetFlavour </parameter>
</processor>

 <processor name="MyOverlay" type="Overlay">
 <!--Opens a second (chain of) lcio file(s) and overlays events...-->
  <!--Pairs of collection to be merged-->
  <parameter name="CollectionMap" type="StringVec">mcParticles mcParticlesBG  </parameter>
  <!--Name of the lcio input file(s)-->
  <parameter name="InputFileNames" type="StringVec">overlay.slcio  </parameter>
  <!--Overlay each event with this number of background events. (default 0)-->
  <parameter name="NumberOverlayEvents" type="int">0 </parameter>
  <!--Add additional background events according to a poisson distribution with this expectation value. (non, if parameter not set)-->
  <parameter name="expBG" type="double">1 </parameter>
  <!--Overlay each event with the content of one run.-->
  <parameter name="runOverlay" type="bool">false </parameter>
</processor>

 <processor name="MyPGDBP" type="PGDBP">
 <!--Physical and Geometrical Database (for Boojum at least)-->
</processor>

 <processor name="MyPandoraPFACalibrator" type="PandoraPFACalibrator">
 <!--PandoraPFACalibrator for calibration of of PandoraPFA-->
  <!--Cluster Collection Name -->
  <parameter name="ClusterCollectionName" type="string">PandoraClusters </parameter>
  <!--Calibration from deposited ECAL MIP to EM energy-->
  <parameter name="ECALEMMIPToGeV" type="float">0.005076 </parameter>
  <!--Calibration from deposited ECAL MIP to Hadronic energy-->
  <parameter name="ECALHadMIPToGeV" type="float">0.005 </parameter>
  <!--Calibration from deposited ECAL energy to MIP-->
  <parameter name="ECALMIPcalibration" type="float">200 </parameter>
  <!--ECAL Threshold in MIPS-->
  <parameter name="ECALThreshold" type="float">0 </parameter>
  <!--Name of the ECAL collection used to form clusters-->
  <parameter name="ECALcollections" type="StringVec" lcioInType="CalorimeterHit">ECAL  </parameter>
  <!--Calibration from deposited HCAL MIP to EM energy-->
  <parameter name="HCALEMMIPToGeV" type="float">0.0233 </parameter>
  <!--Calibration from deposited HCAL MIP to Hadronic energy-->
  <parameter name="HCALHadMIPToGeV" type="float">0.02 </parameter>
  <!--Calibration from deposited HCAL energy to MIP-->
  <parameter name="HCALMIPcalibration" type="float">35 </parameter>
  <!--HCAL Threshold in MIPS-->
  <parameter name="HCALThreshold" type="float">0 </parameter>
  <!--Name of the HCAL collection used to form clusters-->
  <parameter name="HCALcollections" type="StringVec" lcioInType="CalorimeterHit">HCAL  </parameter>
  <!--Name of the LCAL collection used to form clusters-->
  <parameter name="LCALcollections" type="StringVec" lcioInType="CalorimeterHit">LCAL  </parameter>
  <!--Particle Collection Name -->
  <parameter name="ParticleCollectionName" type="string">PandoraPFOs </parameter>
  <!--Name of the Track collection used for clustering-->
  <parameter name="RootFile" type="string">PandoraPFACalibrator.root </parameter>
</processor>

 <processor name="MyPandoraPFAEventDisplay" type="PandoraPFAEventDisplay">
 <!-- description not set by author -->
  <!--Show Jets-->
  <parameter name="DrawJets" type="int">1 </parameter>
  <!--Show PFOs-->
  <parameter name="DrawPFOs" type="int">0 </parameter>
  <!--Show RZ view ?-->
  <parameter name="DrawRZ" type="int">1 </parameter>
  <!--Draw Unused TPC hits-->
  <parameter name="DrawUnused" type="int">0 </parameter>
  <!--Show XY view ?-->
  <parameter name="DrawXY" type="int">1 </parameter>
  <!--Show XZ view ?-->
  <parameter name="DrawXZ" type="int">1 </parameter>
  <!--Jet Collection to display (data only)-->
  <parameter name="JetCollection" type="string">JetAtDetector </parameter>
  <!--PFO Collection to display (data only)-->
  <parameter name="PFOCollection" type="string">PandoraPFOs </parameter>
</processor>

 <processor name="MyPandoraPFAProcessor" type="PandoraPFAProcessor">
 <!--PandoraPFAProcessor reconstructs clusters and particle flow objects-->
  <!--Switch on/off code to fragment photons from MIPS-->
  <parameter name="AllowPhotonFragmentation" type="int">1 </parameter>
  <!--Switch on/off code for statistical reclustering i.e. whether to break up/merge clusters based on track-->
  <parameter name="AllowReclustering" type="int">1 </parameter>
  <!--Turn on internal analysis of clusters-->
  <parameter name="AnalyseClusters" type="int">0 </parameter>
  <!--Name of Root file for PFA Analysis-->
  <!--parameter name="AnalysisRootFile" type="string">PandoraPFAAnalysis.root </parameter-->
  <!--Switch on/off matching of back-scattered tracks-->
  <parameter name="AssociateBackScatters" type="int">1 </parameter>
  <!--Switch on/off matching by proximity-->
  <parameter name="AssociateByProximity" type="int">1 </parameter>
  <!--Switch on/off matching by shower cone-->
  <parameter name="AssociateByShowerCone" type="int">1 </parameter>
  <!--Switch on/off matching-->
  <parameter name="AssociateFromStart" type="int">1 </parameter>
  <!--Switch on/off matching of looping tracks in CALO-->
  <parameter name="AssociateLoopingTracks" type="int">1 </parameter>
  <!--Switch on/off matching of mip track stubs to showers-->
  <parameter name="AssociateMipStubsToShowers" type="int">1 </parameter>
  <!--Switch on/off matching of showers to MIP segments-->
  <parameter name="AssociateShowersToMips" type="int">1 </parameter>
  <!--Switch on/off matching of showers to MIP segments II-->
  <parameter name="AssociateShowersToMipsII" type="int">1 </parameter>
  <!--Switch on/off matching of soft clusters-->
  <parameter name="AssociateSoftClusters" type="int">1 </parameter>
  <!--Switch on/off matching of track segments in CALO-->
  <parameter name="AssociateTrackSegments" type="int">1 </parameter>
  <!--Use MC to cheat particle flow-->
  <parameter name="CFCheck" type="int">0 </parameter>
  <!--Can use cluster energy for PFOs for tracks which exit detector-->
  <parameter name="CanUseClusterForExitingTracks" type="int">1 </parameter>
  <!--Cluster Collection Name -->
  <parameter name="CellIDCoding" type="string">Mokka </parameter>
  <!--Chi cut for reclustering-->
  <parameter name="ChiToAttemptReclustering" type="float">3 </parameter>
  <!--Chi cut for forced reclustering-->
  <parameter name="ChiToForceReclustering" type="float">4 </parameter>
  <!--Cluster Cleaning on/off-->
  <parameter name="ClusterCleaning" type="int">1 </parameter>
  <!--Cluster Collection Name -->
  <parameter name="ClusterCollectionName" type="string" lcioOutType="Cluster">PandoraClusters </parameter>
  <!--tan(angle) used in hit-cluster association-->
  <parameter name="ClusterFormationAngleECAL" type="float">0.3 </parameter>
  <!--tan(angle) used in hit-cluster association-->
  <parameter name="ClusterFormationAngleHCAL" type="float">0.5 </parameter>
  <!--number of pads to add to cone in cluster fortmation-->
  <parameter name="ClusterFormationPadsECAL" type="float">1.5 </parameter>
  <!--number of pads to add to cone in cluster fortmation-->
  <parameter name="ClusterFormationPadsHCAL" type="float">2.5 </parameter>
  <!--0=Step and make assignment in layer then, if none found, step back, 1=step over iback layers and choose best assignment -->
  <parameter name="ClusterFormationStrategy" type="int">0 </parameter>
  <!--Cosine of cone half angle for shower cone assoc-->
  <parameter name="CosineConeAngle" type="float">0.9 </parameter>
  <!--Name of the Curl Killer TPC Hit collection used for kink finding-->
  <parameter name="CurlKilledTpcHitCollection" type="StringVec" lcioInType="TrackerHit">DroppedTPCTrackeHits  </parameter>
  <!--Power for density weighting assuming 1/r^N weighting e.g. 2 = inverse square-->
  <parameter name="DenistyWeightingPower" type="int">2 </parameter>
  <!--If set treat ECAL as digital ECAL-->
  <parameter name="DigitalECAL" type="int">0 </parameter>
  <!--If set treat HCAL as digital HCAL-->
  <parameter name="DigitalHCAL" type="int">0 </parameter>
  <!--Display the ununused tpc hits-->
  <parameter name="DisplayUnusedTpcHits" type="int">0 </parameter>
  <!--Calibration from deposited ECAL MIP to EM energy-->
  <parameter name="ECALEMMIPToGeV" type="float">0.005076 </parameter>
  <!--Calibration from deposited ECAL MIP to Hadronic energy-->
  <parameter name="ECALHadMIPToGeV" type="float">0.005 </parameter>
  <!--Calibration from deposited ECAL energy to MIP-->
  <parameter name="ECALMIPcalibration" type="float">200 </parameter>
  <!--ECAL Threshold in MIPS-->
  <parameter name="ECALThreshold" type="float">0.5 </parameter>
  <!--Name of the ECAL collection used to form clusters-->
  <parameter name="ECALcollections" type="StringVec" lcioInType="CalorimeterHit">ECAL  </parameter>
  <!--Below this enegry tracks are treates as very low wenegry-->
  <parameter name="EnergyCutForVeryLowEnergyTracks" type="float">0.25 </parameter>
  <!--Veto cluster merging based on chi2 difference (Eclust-Etrack)/sigE-->
  <parameter name="EnergyDeltaChi2ForCrudeMerging" type="float">1 </parameter>
  <!--Use additional method to match looping tracks to clusters ? 0=no 1=yes-->
  <parameter name="ExtraLoopingTrackClusterAssociation" type="int">1 </parameter>
  <!--Track - cluster matching cut for FTD only tracks-->
  <parameter name="FTDOnlyTracksMatchingCut" type="float">10 </parameter>
  <!--Minimum number of hits for FTD only tracks-->
  <parameter name="FTDOnlyTracksMinimumHits" type="int">3 </parameter>
  <!--Make a dummy cluster from isolated hits-->
  <parameter name="FormClusterFromUnusedIsolatedHits" type="int">0 </parameter>
  <!--Switch on/off identification and removal of fragment clusters-->
  <parameter name="FragmentRemoval" type="int">1 </parameter>
  <!--Base for chi2 requirement-->
  <parameter name="FragmentRemovalChi2Base" type="float">5 </parameter>
  <!--Fragment removal: weight for cone evidence-->
  <parameter name="FragmentRemovalConeWeight" type="float">1 </parameter>
  <!--Fragment removal contact criterion - cut in pads-->
  <parameter name="FragmentRemovalContactCut" type="float">2 </parameter>
  <!--Fragment removal contact cut criterion - no of layers-->
  <parameter name="FragmentRemovalContactLayersCut" type="int">4 </parameter>
  <!--Fragment removal: weight for contact evidence-->
  <parameter name="FragmentRemovalContactWeight" type="float">1 </parameter>
  <!--Fragment removal: weight for distance evidence-->
  <parameter name="FragmentRemovalDistanceWeight" type="float">1 </parameter>
  <!--Penalty for using global chi2-->
  <parameter name="FragmentRemovalGlobalPenalty" type="float">5 </parameter>
  <!--Fragment removal maximum chi2 for merge-->
  <parameter name="FragmentRemovalMaxChi2ForMerge" type="float">9 </parameter>
  <!--Fragment removal: weight for track extrapolation evidence-->
  <parameter name="FragmentRemovalTrackExtrapolationWeight" type="float">1 </parameter>
  <!--Calibration from deposited HCAL MIP to EM energy-->
  <parameter name="HCALEMMIPToGeV" type="float">0.0233 </parameter>
  <!--Calibration from deposited HCAL MIP to Hadronic energy-->
  <parameter name="HCALHadMIPToGeV" type="float">0.02 </parameter>
  <!--Calibration from deposited HCAL energy to MIP-->
  <parameter name="HCALMIPcalibration" type="float">35 </parameter>
  <!--HCAL Threshold in MIPS-->
  <parameter name="HCALThreshold" type="float">0.3 </parameter>
  <!--Name of the HCAL collection used to form clusters-->
  <parameter name="HCALcollections" type="StringVec" lcioInType="CalorimeterHit">HCAL  </parameter>
  <!--Hadronic energy resolution for pions-->
  <parameter name="HadronicEnergyResolution" type="float">0.6 </parameter>
  <!--Switch to ignore all tracks-->
  <parameter name="IgoreTracks" type="int">0 </parameter>
  <!--density weight cut for isolation in ECAL-->
  <parameter name="IsolationDensityWeightCutECAL" type="float">0.5 </parameter>
  <!--density weight cut for isolation in HCAL-->
  <parameter name="IsolationDensityWeightCutHCAL" type="float">0.25 </parameter>
  <!--distance (absolute) within layer for ECAL isolation/mm-->
  <parameter name="IsolationDistanceECAL" type="float">50 </parameter>
  <!--sweep up isolated hits within radius-->
  <parameter name="IsolationDistanceForReCombination" type="float">200 </parameter>
  <!--distance (absolute) within layer for HCAL isolation /mm-->
  <parameter name="IsolationDistanceHCAL" type="float">250 </parameter>
  <!--Type of isolation cut : 0=NONE; 1=DENSITY, 2=MULTIPLICITY-->
  <parameter name="IsolationType" type="int">1 </parameter>
  <!--Calibration from deposited LCAL MIP to EM energy-->
  <parameter name="LCALEMMIPToGeV" type="float">0.005076 </parameter>
  <!--Calibration from deposited LCAL energy to MIP-->
  <parameter name="LCALMIPcalibration" type="float">35 </parameter>
  <!--LCAL Threshold in MIPS-->
  <parameter name="LCALThreshold" type="float">0.5 </parameter>
  <!--Name of the LCAL collections-->
  <parameter name="LCALcollections" type="StringVec" lcioInType="CalorimeterHit">LCAL  </parameter>
  <!--Number of layers (other than current) for density weighting-->
  <parameter name="LayersForDensityWeighting" type="int">2 </parameter>
  <!--Number of ECAL layers for isolation cuts-->
  <parameter name="LayersForIsolationECAL" type="int">2 </parameter>
  <!--Number of HCAL layers for isolation cuts-->
  <parameter name="LayersForIsolationHCAL" type="int">2 </parameter>
  <!--Maximum Number of layers in ECAL over which cluster associations are made-->
  <parameter name="LayersToStepBackECAL" type="int">3 </parameter>
  <!--Maximum Number of layers in HCAL over which cluster associations are made-->
  <parameter name="LayersToStepBackHCAL" type="int">3 </parameter>
  <!--Maximum distance of closest approach for looping track assoc-->
  <parameter name="LooperClosestApproachCutECAL" type="float">200 </parameter>
  <!--Maximum distance between ends of clusters for looping track assoc-->
  <parameter name="LooperTrackSeparationCut" type="float">250 </parameter>
  <!--Name of the MUON collections-->
  <parameter name="MUONcollections" type="StringVec" lcioInType="CalorimeterHit">MUON  </parameter>
  <!--Chi cut for Killing track-->
  <parameter name="MatchingChiToKillTrack" type="float">4 </parameter>
  <!--cut on distance for cone association ECAL-->
  <parameter name="MaximumDistanceForConeAssociationECAL" type="float">250 </parameter>
  <!--cut on distance for cone association HCAL-->
  <parameter name="MaximumDistanceForConeAssociationHCAL" type="float">500 </parameter>
  <!--Distance cuts for joining soft clusters-->
  <parameter name="MaximumDistanceForSoftCluster" type="float">500 </parameter>
  <!--maximum number of hits for cluster to be considered soft-->
  <parameter name="MaximumHitsInSoftCluster" type="int">9 </parameter>
  <!--Merge hard photon fragments-->
  <parameter name="MergeHardPhotons" type="int">1 </parameter>
  <!--Merge soft photon fragments-->
  <parameter name="MergeSoftPhotons" type="int">1 </parameter>
  <!--Switch on/off photon merging-->
  <parameter name="MergeSplitPhotons" type="int">1 </parameter>
  <!--minimum energy for EM cluster-->
  <parameter name="MinimumClusterEnergyEM" type="float">0.1 </parameter>
  <!--minimum energy for HAD cluster-->
  <parameter name="MinimumClusterEnergyHAD" type="float">0.5 </parameter>
  <!--minimum number of hits in standalone cluster-->
  <parameter name="MinimumHitsInCluster" type="int">5 </parameter>
  <!--minimum number of track hits (applies to Si/FTD)-->
  <parameter name="MinimumTrackHits" type="int">5 </parameter>
  <!--Number of pads over which to count for MIP mulitplicity-->
  <parameter name="MipCells" type="int">1 </parameter>
  <!--Maximum energy (mips) for hit to be tagged as mip like-->
  <parameter name="MipLikeMipCut" type="float">5 </parameter>
  <!--Maximum Number of mip cells hit for hit to be tagged as candidate MIP-->
  <parameter name="MipMaxCellsHit" type="int">1 </parameter>
  <!--number of Mips per hit for hadron to be flagged as hot-->
  <parameter name="MipsPerHitForHotHadron" type="float">15 </parameter>
  <!--Region defined as outer HCAL-->
  <parameter name="OuterHCAL" type="int">10 </parameter>
  <!--Particle Collection Name -->
  <parameter name="ParticleCollectionName" type="string" lcioOutType="ReconstructedParticle">PandoraPFOs </parameter>
  <!--Use MC to cheat particle flow-->
  <parameter name="PerfectPFA" type="int">0 </parameter>
  <!--Cut in energy matching for non-IDed fragmented photons-->
  <parameter name="PhotonFragNonPhotonDeltaChi2Cut" type="float">0 </parameter>
  <!--Cut in energy matching for IDed fragmented photons-->
  <parameter name="PhotonFragPhotonDeltaChi2Cut" type="float">1 </parameter>
  <!--Switch on/off code for photon recovery-->
  <parameter name="PhotonRecovery" type="int">1 </parameter>
  <!--Debug printing-->
  <parameter name="Printing" type="int">1 </parameter>
  <!--Draw the display-->
  <parameter name="RecoDisplay" type="int">0 </parameter>
  <!--zyz range to be displayed -->
  <parameter name="RecoDisplayPlotRange" type="float">4250 </parameter>
  <!--Name of the calo hit <-> sim calo hit relation-->
  <parameter name="RelationCaloString" type="string" lcioInType="LCRelation">RelationCaloHit </parameter>
  <!--Name of the track hit <-> sim track hit relation-->
  <parameter name="RelationTrackString" type="string" lcioInType="LCRelation">TrueTracksMCP </parameter>
  <!--Number of HCAL layers used-->
  <parameter name="RestrictHCALToNLayers" type="int">9999 </parameter>
  <!--distance in number of pads for same layer assoc-->
  <parameter name="SameLayerPadCutECAL" type="float">1.8 </parameter>
  <!--distance in number of pads for same layer assoc-->
  <parameter name="SameLayerPadCutHCAL" type="float">1.8 </parameter>
  <!--number of Mips per hit used to scale hot hadron energies-->
  <parameter name="ScaledMipsPerHitForHotHadron" type="float">5 </parameter>
  <!--Search for back scatters?-->
  <parameter name="SearchForBackScatterss" type="int">1 </parameter>
  <!--Search for kinks?-->
  <parameter name="SearchForKinks" type="int">1 </parameter>
  <!--Search for prongs?-->
  <parameter name="SearchForProngs" type="int">1 </parameter>
  <!--Search for split tracks?-->
  <parameter name="SearchForSplitTracks" type="int">1 </parameter>
  <!--Search for V0s?-->
  <parameter name="SearchForV0s" type="int">1 </parameter>
  <!--Step through cluster association on display-->
  <parameter name="ShowProtoClusterAssociation" type="int">0 </parameter>
  <!--Step through cluster formation on display-->
  <parameter name="ShowProtoClusterFormation" type="int">0 </parameter>
  <!--number of hits for smallest cluster size when tagging isolated hits-->
  <parameter name="SmallestClusterSize" type="int">3 </parameter>
  <!--maximum energy for HAD cluster to be considered soft-->
  <parameter name="SoftClusterEnergyHAD" type="float">2 </parameter>
  <!--Energy for cluster to be considered a soft photon fragment-->
  <parameter name="SoftPhotonMergingEnergy" type="float">0.2 </parameter>
  <!--Name of the TPC Hit collection used for kink finding-->
  <parameter name="TpcHitCollections" type="StringVec" lcioInType="TrackerHit">UsedTPCTrackerHits  </parameter>
  <!--Name of the Track collection used for clustering-->
  <parameter name="TrackCollections" type="StringVec" lcioInType="Track">TrueTracks  </parameter>
  <!--track merging distance in  ECAL-->
  <parameter name="TrackMergeCutEcal" type="float">25 </parameter>
  <!--track merging distance in  HCAL-->
  <parameter name="TrackMergeCutHcal" type="float">25 </parameter>
  <!--track merging perp distance in  ECAL-->
  <parameter name="TrackMergePerpCutEcal" type="float">50 </parameter>
  <!--track merging perp distance in  HCAL-->
  <parameter name="TrackMergePerpCutHcal" type="float">75 </parameter>
  <!--Use tracks to seed clusters ? 0=no, 1=only barrel loopers, 2=all loopers, 3=all tracks-->
  <parameter name="TrackSeeding" type="int">3 </parameter>
  <!--weight given to tracking in protocluster formation-->
  <parameter name="TrackingWeight" type="int">2 </parameter>
  <!--How hits are ordered within Layer : 0 = PseudoEnergy, 1 = density within layer, 2=local density over layers-->
  <parameter name="TypeOfOrderingInLayer" type="int">1 </parameter>
  <!--Maximum energy for unmatched vertex track-->
  <parameter name="UnmatchedVertexTrackEnergyCut" type="float">5 </parameter>
  <!--Final photon ID based on longitudinal profile-->
  <parameter name="UseAdvancedPhotonID" type="int">1 </parameter>
  <!--Use tracks with only FTD and Si hits-->
  <parameter name="UseFTDOnlyTracks" type="int">1 </parameter>
  <!--Use tracks which don't originate from vertex-->
  <parameter name="UseNonVertexTracks" type="int">1 </parameter>
  <!--Use only the end of the track in the main extrap-->
  <parameter name="UseTrackEndIntersection" type="int">0 </parameter>
  <!--Use unmatched tracks which don't originate from vertex-->
  <parameter name="UseUnmatchedNonVertexTracks" type="int">0 </parameter>
  <!--Use unmatched vertex/kink tracks-->
  <parameter name="UseUnmatchedVertexTracks" type="int">1 </parameter>
  <!--UsingCheatedDeDx ?-->
  <parameter name="UsingCheatedDeDx" type="int">0 </parameter>
  <!--Muon hits used as tail catcher-->
  <parameter name="UsingMuonHitsAsTailCatcher" type="int">1 </parameter>
  <!--Muon hits used to identifying leaving clusters-->
  <parameter name="UsingMuonHitsToAidClustering" type="int">1 </parameter>
  <!--cut on d0 to define good tracks-->
  <parameter name="d0TrackCut" type="float">50 </parameter>
  <!--width of mass window used to identify K->mu nu-->
  <parameter name="kToMuMassWindowWidth" type="float">0.125 </parameter>
  <!--width of mass window used to identify pi->mu nu-->
  <parameter name="piToMuMassWindowWidth" type="float">0.03 </parameter>
  <!--cut on z0 to define good tracks-->
  <parameter name="z0TrackCut" type="float">50 </parameter>
</processor>

 <processor name="MyPedestalCalculator" type="PedestalCalculator">
 <!--PedestalCalculator: calculate the pedestal (mean and width)-->
  <!--name of the data base output file (existing file will be overwritten) if empty no file is written-->
  <parameter name="DBOutputFileName" type="string"> </parameter>
  <!--name of the collection writen to the current data stream make use of writeEveryNEvents  if empty no collection is written PLEASE NOTE: the conditions data will not be valied in right time periode-->
  <parameter name="EventStreamCollectionName" type="string"> </parameter>
  <!--Name of the input collection-->
  <parameter name="InputCollectionName" type="string">TPCConvertedRawData </parameter>
  <!--name of the output collection-->
  <parameter name="OutputCollectionName" type="string">TPCPedestal </parameter>
  <!--name of the simple output file (existing file will be overwritten) if empty no file is written in one file only one Collection is saved, valid time will added in the file name before the dot-->
  <parameter name="OutputFileName" type="string"> </parameter>
  <!--since time of first entry in ns since 1.1.1970 00:00:00 UTCif -1 the time of the first event will be taken-->
  <parameter name="validSince" type="string">-1 </parameter>
  <!--since time of last entry in ns since 1.1.1970 00:00:00 UTCif -1 the time of the last event will be taken-->
  <parameter name="validTill" type="string">-1 </parameter>
  <!--write the the collection every N events ( -1: write only at the end)-->
  <parameter name="writeEveryNEvents" type="int">-1 </parameter>
</processor>

 <processor name="MyPedestalSubtractorProcessor" type="PedestalSubtractorProcessor">
 <!--PedestalSubtractorProcessor correct the TrackerData by subtracting the pedestals provided via a file-->
  <!--Name of the input collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="TrackerData">TPCConvertedRawData </parameter>
  <!--Name of the output collection-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="TrackerData">TPCData </parameter>
  <!--Name of the collection containing the pedestals-->
  <parameter name="PedestalCollectionName" type="string">TPCPedestal </parameter>
  <!--if not 0 the output collection is set transient-->
  <parameter name="SetOutputTransient" type="int">1 </parameter>
</processor>

 <processor name="MyPerEventIPFitterProcessor" type="PerEventIPFitterProcessor">
 <!--Per Event IP fitter - trims tracks to reach probabililty threshold-->
  <!--Manually set default error matrix of the primary vertex (cm) (lower symmetric)-->
  <parameter name="DefaultIPError" type="FloatVec">2.5e-05 0 2.5e-05 0 0 0.0004  </parameter>
  <!--Manually set default position of the IP vertex (cm)-->
  <parameter name="DefaultIPPosition" type="FloatVec">0 0 0  </parameter>
  <!--Name of the ReconstructedParticle collection contains tracks to fit-->
  <parameter name="InputRPCollection" type="string" lcioInType="ReconstructedParticle">EventTracks </parameter>
  <!--Name of the Vertex collection of the output ip vertex-->
  <parameter name="OutputVertexCollection" type="string" lcioOutType="Vertex">IPVertex </parameter>
  <!--Tracks are removed until this threshold is reached-->
  <parameter name="ProbabilityThreshold" type="double">0.01 </parameter>
</processor>

 <processor name="MyPhiLambdaDistributionProcessor" type="PhiLambdaDistributionProcessor">
 <!--PhiLambdaDistributionProcessor: Fill phi, lambda, and z distribution of hits in tracks into AIDA histgram-->
  <!--Maximal value in lambda histogram (default:  50. mrad)-->
  <parameter name="HistogramMaxValueLambda" type="float">50 </parameter>
  <!--Maximal value in phi histogram (default: 50. mrad)-->
  <parameter name="HistogramMaxValuePhi" type="float">50 </parameter>
  <!--Minimum value in lambda histogram (default: -50. mrad)-->
  <parameter name="HistogramMinValueLambda" type="float">-50 </parameter>
  <!--Minimum value in phi histogram (default: -50. mrad)-->
  <parameter name="HistogramMinValuePhi" type="float">-50 </parameter>
  <!--Name of the input tracks collection-->
  <parameter name="InputTracks" type="string" lcioInType="Track">TPCSeedTracks </parameter>
</processor>

 <processor name="MyPlot" type="Plot">
 <!--Plots various outputs from the flavour tag-->
  <!--Name of the LCFloatVec Collections that contain the flavour tags (one purity efficiency plot per tag) (in same order as jet collection)-->
  <parameter name="FlavourTagCollections" type="StringVec">FlavourTag  </parameter>
  <!--Name of the collection of ReconstructedParticles that is the jet-->
  <parameter name="JetCollectionName" type="string" lcioInType="ReconstructedParticle">SGVJets </parameter>
  <!--Filename for the output-->
  <parameter name="OutputFilename" type="string">PlotProcessorOutput </parameter>
  <!--Name of the output collection of LCIntVec (same order as jets)-->
  <parameter name="TrueJetFlavourCollection" type="string" lcioInType="LCFloatVec">TrueJetFlavour </parameter>
</processor>

 <processor name="MyPrimaryIonisationProcessor" type="PrimaryIonisationProcessor">
 <!--PrimaryIonisationProcessor creates electrons along mcparticle track ...-->
  <!--File with Information about #e- in Cluster-->
  <parameter name="ClusterInfo" type="string">clusterinfofile </parameter>
  <!--switch on simulation of low momentum particles -->
  <parameter name="FullCurler" type="int">1 </parameter>
  <!--Name of the input collection with MCParticles-->
  <parameter name="InputCollectionName" type="string" lcioInType="MCParticle">MCParticle </parameter>
  <!--Name of the output collection with primary electrons-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="SimTrackerHit">PrimaryElectrons </parameter>
  <!--switch off writing of output collection-->
  <parameter name="Transient" type="int">0 </parameter>
</processor>

 <processor name="MyPulseFinderProcessor" type="PulseFinderProcessor">
 <!--PulseFinderProcessor: find hits out of the raw data and calculate the time and charge information-->
  <!--if not 0 the ADC spectrum will be stored for all pulses-->
  <parameter name="ForceSpectrumSave" type="int">1 </parameter>
  <!--Name of the input TrackerData collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="TrackerData">TPCData </parameter>
  <!--Name of the output TrackerData collectiononly the data related to a pulse will be stored-->
  <parameter name="OutputTrackerDataCollectionName" type="string" lcioOutType="TrackerData">TPCDataInPulses </parameter>
  <!--Name of the output TrackerPulse collection-->
  <parameter name="OutputTrackerPulseCollectionName" type="string" lcioOutType="TrackerPulse">TPCPulses </parameter>
  <!--Name of the collection containing the pedestal information-->
  <parameter name="PedestalCollectionName" type="string">TPCPedestal </parameter>
  <!--a pulse start if ADC value is the given value times width of the pedestal-->
  <parameter name="PulseStartThreshold" type="float">5 </parameter>
  <!--# bins saved after the start bin (exept there is another pulse)-->
  <parameter name="SaveNBinsAfterStart" type="int">8 </parameter>
  <!--# bins saved before the start bin (exept there is another pulse)-->
  <parameter name="SaveNBinsBeforeStart" type="int">2 </parameter>
  <!--if not 0 the output collection is set transient-->
  <parameter name="SetOutputTransient" type="int">1 </parameter>
</processor>

 <processor name="MyRPCutProcessor" type="RPCutProcessor">
 <!--RPCutProcessor - cuts RPs based on several criteria removing those that have no tracks-->
  <!--Name of the ReconstructedParticle collection which will be cut-->
  <parameter name="InputRCPCollection" type="string" lcioInType="ReconstructedParticle">Jets </parameter>
  <!--Name of the output ReconstructedParticle collection when WriteNewCollection is true-->
  <parameter name="OutputRCPCollection" type="string" lcioOutType="ReconstructedParticle">CutJets </parameter>
  <!--If true cuts tracks from the particle lists of particles in InputRCPCollection, if false just cuts particles from InputRCPCollection-->
  <parameter name="SubParticleLists" type="bool">true </parameter>
  <!--If true writes the cut jet to a new collection (OutputJetRCPCollection) if false overwrites input-->
  <parameter name="WriteNewCollection" type="bool">true </parameter>
  <!--Enable a cut on the value of each tracks chi squared over degrees of freedom-->
  <!--parameter name="a1_Chi2OverDOFEnable" type="bool">false </parameter-->
  <!--If true values lower than the cut value will be cut, if false values higher will be cut-->
  <!--parameter name="a2_Chi2OverDOFCutLowerThan" type="bool">false </parameter-->
  <!--Cut Value-->
  <!--parameter name="a3_Chi2OverDOFCutValue" type="float">10 </parameter-->
  <!--Enable a cut on the value of each tracks d0 (no correction for ref point position)-->
  <!--parameter name="b1_D0Enable" type="bool">false </parameter-->
  <!--If true values lower than the cut value will be cut, if false values higher will be cut-->
  <!--parameter name="b2_D0CutLowerThan" type="bool">false </parameter-->
  <!--Cut Value-->
  <!--parameter name="b3_D0CutValue" type="float">20 </parameter-->
  <!--Enable a cut on the value of each tracks d0 Error (sqrt(covariance(d0,d0))-->
  <!--parameter name="c1_D0ErrEnable" type="bool">false </parameter-->
  <!--If true values lower than the cut value will be cut, if false values higher will be cut-->
  <!--parameter name="c2_D0ErrCutLowerThan" type="bool">false </parameter-->
  <!--Cut Value-->
  <!--parameter name="c3_D0ErrCutValue" type="float">0.25 </parameter-->
  <!--Enable a cut on the value of each tracks Z0 (no correction for ref point position)-->
  <!--parameter name="d1_Z0Enable" type="bool">false </parameter-->
  <!--If true values lower than the cut value will be cut, if false values higher will be cut-->
  <!--parameter name="d2_Z0CutLowerThan" type="bool">false </parameter-->
  <!--Cut Value-->
  <!--parameter name="d3_Z0CutValue" type="float">20 </parameter-->
  <!--Enable a cut on the value of each tracks z0 Error (sqrt(covariance(z0,z0))-->
  <!--parameter name="e1_Z0ErrEnable" type="bool">false </parameter-->
  <!--If true values lower than the cut value will be cut, if false values higher will be cut-->
  <!--parameter name="e2_Z0ErrCutLowerThan" type="bool">false </parameter-->
  <!--Cut Value-->
  <!--parameter name="e3_Z0ErrCutValue" type="float">0.25 </parameter-->
  <!--Enable a cut on the value of each tracks PT (radial magnitude of ReconstructedParticle->momentum())-->
  <!--parameter name="f1_PTEnable" type="bool">false </parameter-->
  <!--If true values lower than the cut value will be cut, if false values higher will be cut-->
  <!--parameter name="f2_PTCutLowerThan" type="bool">true </parameter-->
  <!--Cut Value-->
  <!--parameter name="f3_PTCutValue" type="float">0.1 </parameter-->
  <!--Enable a cut on the number seen hits in sub detectors - for more details see documentation-->
  <!--parameter name="g1_DetectorHitsEnable" type="bool">false </parameter-->
  <!--Sub detector names in same order as result of Track->getSubdetectorHitNumbers()-->
  <!--parameter name="g2_SubDetectorNames" type="StringVec">VTX FTD SIT TPC  </parameter-->
  <!--Sub detector names of detectors defining the boundary between region 1 and region 2-->
  <!--parameter name="g3_DetectorHitsBoundaryDetectorNames" type="StringVec">TPC FTD  </parameter-->
  <!--Corresponding to the order of DetectorHitsBoundaryDetectorNames the max number of hits for each detector for region 1, if any of the sub detectors has a higher number of hits then region 2 is used-->
  <!--parameter name="g4_DetectorHitsBoundaryCuts" type="IntVec">20 3  </parameter-->
  <!--Sub detector names of detectors used for cutting in region 1-->
  <!--parameter name="g5_DetectorHitsRegion1DetectorNames" type="StringVec">VTX  </parameter-->
  <!--Corresponding to the order of DetectorHitsRegion1DetectorNames the minimum number of hits for region 1 for a track to pass-->
  <!--parameter name="g6_DetectorHitsRegion1Cuts" type="IntVec">3  </parameter-->
  <!--Sub detector names of detectors used for cutting in region 2-->
  <!--parameter name="g7_DetectorHitsRegion2DetectorNames" type="StringVec">VTX  </parameter-->
  <!--Corresponding to the order of DetectorHitsRegion2DetectorNames the minimum number of hits for region 2 for a track to pass-->
  <!--parameter name="g8_DetectorHitsRegion2Cuts" type="IntVec">0  </parameter-->
  <!--Enable a cut on the PDG code of the parent of Monte Carlo particle associated with the track. Set the codes to cut on in CutPIDS and the LCRelation collection name to the MC data in MonteCarloLCRelationCollection-->
  <!--parameter name="h1_MCPIDEnable" type="bool">false </parameter-->
  <!--A list of all the PDG codes of the parent Monte Carlo particle to cut-->
  <!--parameter name="h2_CutPIDS" type="IntVec">0  </parameter-->
  <!--Name of the LCRelation collection which links InputRCPCollection to the Monte Carlo data. Required only if MCPIDEnable is true-->
  <parameter name="h3_MonteCarloLCRelationCollection" type="string" lcioInType="LCRelation">Relations </parameter>
  <!--Enable a cut on tracks with NaN parameters or covariances-->
  <!--parameter name="i1_BadParametersEnable" type="bool">false </parameter-->
  <!--Enable a cut on tracks with MC Production Vertices in material-->
  <!--parameter name="j1_MCVertexCut" type="bool">false </parameter-->
</processor>

 <processor name="MyRecoMCTruthLinker" type="RecoMCTruthLinker">
 <!--links RecontructedParticles to the MCParticle based on number of hits used-->
  <!--PDG codes of particles of which the daughters will be kept in the skimmmed MCParticle collection-->
  <parameter name="KeepDaughtersPDG" type="IntVec">22 111 310  </parameter>
  <!--Name of the MCParticle input collection-->
  <parameter name="MCParticleCollection" type="string" lcioInType="MCParticle">MCParticle </parameter>
  <!--Name of the skimmed MCParticle  output collection-->
  <parameter name="MCParticlesSkimmedName" type="string" lcioOutType="MCParticle">MCParticlesSkimmed </parameter>
  <!--Name of the RecoMCTruthLink output collection-->
  <parameter name="RecoMCTruthLinkName" type="string" lcioOutType="LCRelation">RecoMCTruthLink </parameter>
  <!--Name of the ReconstructedParticles input collection-->
  <parameter name="RecoParticleCollection" type="string" lcioInType="ReconstructedParticle">ReconstructedParticles </parameter>
  <!--Name of the  SimCalorimeterHit - CalorimeterHit relation-->
  <parameter name="SimCalorimeterHitRelationName" type="string" lcioInType="LCRelation">SimCalorimeterHitRelation </parameter>
  <!--Name of the  SimTrackerHit - TrackerHit relation-->
  <parameter name="SimTrackerHitRelationName" type="string" lcioInType="LCRelation">SimTrackerHitRelation </parameter>
  <!--energy cut for daughters that are kept from KeepDaughtersPDG-->
  <parameter name="daughtersECutMeV" type="float">10 </parameter>
</processor>

 <processor name="MySatoruJetFinderProcessor" type="SatoruJetFinderProcessor">
 <!--A multi algorithm jet finder-->
  <!--Set debug level-->
  <!--parameter name="Debug" type="int">0 </parameter-->
  <!--Jet energycut for cone jet finding algorithm with variable number of jets-->
  <!--parameter name="EpsCone" type="float">7 </parameter-->
  <!--mode for manual alogorithm selection, see documentation for details-->
  <!--parameter name="GlobalMode" type="string">0A </parameter-->
  <!--Collection of reconstructed particles-->
  <parameter name="InputCollection" type="string" lcioInType="ReconstructedParticle">Unset </parameter>
  <!--Merging mode, if mode is "manual"-->
  <!--parameter name="MergingMode" type="int">0 </parameter-->
  <!--Merging threshold, if mode is "manual"-->
  <!--parameter name="MergingThreshold" type="float">0 </parameter-->
  <!--Select predefined algorithms for jet finding(or "manual")-->
  <parameter name="Mode" type="string">manual </parameter>
  <!--Force everything to N jets(if supported by current mode)-->
  <!--parameter name="NJetRequested" type="int">4 </parameter-->
  <!--Name of collection with the found jets-->
  <parameter name="OutputCollection" type="string" lcioOutType="ReconstructedParticle">Unset </parameter>
  <!--Primary jet finding mode, if mode is "manual"-->
  <!--parameter name="PrimaryJetFindingMode" type="int">0 </parameter-->
  <!--Half cone opening angle for cone jet finding algorithm with variable number of jet-->
  <!--parameter name="RCone" type="float">0.7 </parameter-->
  <!--Secong jet finding mode, if mode is "manual"-->
  <!--parameter name="SecondJetFindingMode" type="int">0 </parameter-->
  <!--Name of parameter added to event in case of successful jet finding-->
  <!--parameter name="SuccessTag" type="string">JetsFound </parameter-->
  <!--Threshold, if mode is "manual"-->
  <!--parameter name="Threshold" type="float">0 </parameter-->
  <!--YCut for jet finding algorithm(if supported by current mode)-->
  <!--parameter name="YCut" type="float">0 </parameter-->
</processor>

 <processor name="MySelectEvents" type="SelectEvents">
 <!--SelectEvent Processor selects certain events from input files-->
  <!--First Event-->
  <parameter name="FirstEvent" type="int">0 </parameter>
  <!--Last Event-->
  <parameter name="LastEvent" type="int">0 </parameter>
</processor>

 <processor name="MySelectReconstructedParticle" type="SelectReconstructedParticle">
 <!--SelectReconstructedParticle: Selects particles from all reconstructed particles to be used for the thrust finder-->
  <!--Minimum momentum a particle has to have to be used for the thrust calculation-->
  <parameter name="MinimumMomentum" type="float">0 </parameter>
  <!--Collection of reconstructed particles to chose from-->
  <parameter name="inputCollectionName" type="string" lcioInType="ReconstructedParticle">ReconstructedParticle </parameter>
  <!--Collection of selected reconstructed particles-->
  <parameter name="outputCollectionName" type="string" lcioOutType="ReconstructedParticle">SelectedReconstructedParticle </parameter>
</processor>

 <processor name="MySiTrkClusteringProcessor" type="SiTrkClusteringProcessor">
 <!--SiTrkClusteringProcessor: to find hits from digis of Si tracker subdetector.-->
  <!--Name of the TrackerRawData collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="TrackerRawData">dummy </parameter>
  <!--Name of the second TrackerRawData collection-->
  <parameter name="InputCollectionName_second" type="string" lcioInType="TrackerRawData">dummy </parameter>
  <!--Name of the raw to sim relation-collection-->
  <parameter name="InputRelColName" type="string" lcioInType="LCRelation">dummy </parameter>
  <!--Name of the output TrackerHit collection-->
  <parameter name="OutputCollections" type="string" lcioOutType="TrackerHit">dummy </parameter>
  <!--Name of the output raw trackerhit relation collection-->
  <parameter name="OutputRelColName" type="string" lcioOutType="LCRelation">dummy </parameter>
  <!-- equals 1 if print run header information-->
  <parameter name="PrintRunHeaderInform" type="int">0 </parameter>
  <!--Subdetector name, type of technology-->
  <parameter name="SubDet_Technology" type="StringVec"> </parameter>
</processor>

 <processor name="MySiTrkDigiProcessor" type="SiTrkDigiProcessor">
 <!--SiTrkDigiProcessor: digitization of Si tracker subdetector.-->
  <!--Name of the SimTrackerHit collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="SimTrackerHit">dummy </parameter>
  <!--Name of the output raw tracker data collection-->
  <parameter name="OutputCollections" type="string" lcioOutType="TrackerRawData">dummy </parameter>
  <!--Name of the output raw to sim. relation collection-->
  <parameter name="OutputRelColName" type="string" lcioOutType="LCRelation">dummy </parameter>
  <!-- equals 1 if print run header information-->
  <parameter name="PrintRunHeaderInform" type="int">0 </parameter>
  <!--Subdetector name, type of technology-->
  <parameter name="SubDet_Technology" type="StringVec"> </parameter>
</processor>

 <processor name="MySignificanceFit" type="SignificanceFit">
 <!-- description not set by author -->
  <!--Maximum value for the local fitting of the first exponential, starting point Cutoffgauss-->
  <!--parameter name="Cutoffexp1" type="double">40 </parameter-->
  <!--Maximum value for the local fitting of the second exponential, starting point Cutoffexp1-->
  <!--parameter name="Cutoffexp2" type="double">200 </parameter-->
  <!--Maximum value for the local fitting of the gaussian, starting point 0-->
  <!--parameter name="Cutoffgauss" type="double">5 </parameter-->
  <!--Initialization value for amplitude of both exponentials in the exponentials local fit-->
  <!--parameter name="ExpAmlitudeInit" type="double">100 </parameter-->
  <!--Initialization value for decay constant of both exponentials in the exponentials local fit-->
  <!--parameter name="ExpLambdaInit" type="double">0 </parameter-->
  <!--Initialization value for Gauss amplitude in the Gaussian local fit-->
  <!--parameter name="GaussAmlitudeInit" type="double">5000 </parameter-->
  <!--Initialization value for Gauss sigma in the Gaussian local fit-->
  <!--parameter name="GaussSigmaInit" type="double">2 </parameter-->
  <!--Name of the Vertex collection that contains the primary vertex (Optional)-->
  <parameter name="IPVertexCollection" type="string" lcioInType="Vertex">IPVertex </parameter>
  <!--Name of the ReconstructedParticle collection that represents jets-->
  <parameter name="JetRPCollection" type="string" lcioInType="ReconstructedParticle">Jets </parameter>
</processor>

 <processor name="MySiliconTracking" type="SiliconTracking">
 <!--Pattern recognition in silicon trackers-->
  <!--Angle Cut For Merging-->
  <parameter name="AngleCutForMerging" type="float">0.1 </parameter>
  <!--Check for Delta rays hits in hit-to-track assignment-->
  <parameter name="CheckForDelta" type="int">1 </parameter>
  <!--Chi2 Fit Cut-->
  <parameter name="Chi2FitCut" type="float">120 </parameter>
  <!--Chi2 Prefit Cut-->
  <parameter name="Chi2PrefitCut" type="float">1e+10 </parameter>
  <!--Chi2WRphiQuartet-->
  <parameter name="Chi2WRphiQuartet" type="float">1 </parameter>
  <!--Chi2WRphiSeptet-->
  <parameter name="Chi2WRphiSeptet" type="float">1 </parameter>
  <!--Chi2WRphiTriplet-->
  <parameter name="Chi2WRphiTriplet" type="float">1 </parameter>
  <!--Chi2WZQuartet-->
  <parameter name="Chi2WZQuartet" type="float">0.5 </parameter>
  <!--Chi2WZSeptet-->
  <parameter name="Chi2WZSeptet" type="float">0.5 </parameter>
  <!--Chi2WZTriplet-->
  <parameter name="Chi2WZTriplet" type="float">0.5 </parameter>
  <!--Create Track To MCP Relations-->
  <parameter name="CreateMap" type="int">1 </parameter>
  <!--cut on D0 for tracks-->
  <parameter name="CutOnD0" type="float">100 </parameter>
  <!--cut on Pt-->
  <parameter name="CutOnPt" type="float">0.05 </parameter>
  <!--cut on Z0 for tracks-->
  <parameter name="CutOnZ0" type="float">100 </parameter>
  <!--Print out debugging info?-->
  <parameter name="Debug" type="int">1 </parameter>
  <!--FTD Hit Collection Name-->
  <parameter name="FTDHitCollectionName" type="string" lcioInType="TrackerHit">FTDTrackerHits </parameter>
  <!--Fast attachment-->
  <parameter name="FastAttachment" type="int">0 </parameter>
  <!--Final Refit ?-->
  <parameter name="FinalRefit" type="int">1 </parameter>
  <!--Combinations of Hits in Layers-->
  <parameter name="LayerCombinations" type="IntVec">6 4 3 6 4 2 6 3 2 5 4 3 5 4 2 5 3 2 5 3 1 5 2 1 4 3 2 4 3 1 4 2 1 3 2 1  </parameter>
  <!--Combinations of Hits in FTD-->
  <parameter name="LayerCombinationsFTD" type="IntVec">6 5 4 6 5 3 5 4 3 5 4 2 5 4 1 5 3 2 5 3 1 5 2 1 4 3 2 4 3 1 4 3 0 4 2 1 4 2 0 4 1 0 3 2 1 3 2 0 3 1 0 2 1 0  </parameter>
  <!--MinDistCutAttach-->
  <parameter name="MinDistCutAttach" type="float">2.5 </parameter>
  <!--Minimal distance of track hit to the delta electron hit-->
  <parameter name="MinDistToDelta" type="float">0.25 </parameter>
  <!--MinLayerToAttach-->
  <parameter name="MinLayerToAttach" type="int">-1 </parameter>
  <!--minimal hits-->
  <parameter name="MinimalHits" type="int">3 </parameter>
  <!--Number of divisions in Phi-->
  <parameter name="NDivisionsInPhi" type="int">80 </parameter>
  <!--Number of divisions in Phi for FTD-->
  <parameter name="NDivisionsInPhiFTD" type="int">30 </parameter>
  <!--Number of divisions in Theta-->
  <parameter name="NDivisionsInTheta" type="int">80 </parameter>
  <!--Option of prefit ?-->
  <parameter name="OptPrefit" type="int">0 </parameter>
  <!--SIT Hit Collection Name-->
  <parameter name="SITHitCollectionName" type="string" lcioInType="TrackerHit">SITTrackerHits </parameter>
  <!--Silicon track Collection Name-->
  <parameter name="SiTrackCollectionName" type="string" lcioOutType="Track">SiTracks </parameter>
  <!--Name of Si track MC particle relation collection-->
  <parameter name="SiTrackMCPRelCollection" type="string" lcioOutType="LCRelation">SiTracksMCP </parameter>
  <!--Simple Helix Fit ?-->
  <parameter name="SimpleHelixFit" type="int">1 </parameter>
  <!--Use Extra Point in Fit-->
  <parameter name="UseExtraPoint" type="int">0 </parameter>
  <!--Use SIT-->
  <parameter name="UseSIT" type="int">1 </parameter>
  <!--VTX Hit Collection Name-->
  <parameter name="VTXHitCollectionName" type="string" lcioInType="TrackerHit">VTXTrackerHits </parameter>
</processor>

 <processor name="MySimpleCaloDigi" type="SimpleCaloDigi">
 <!--Performs simple digitization of sim calo hits...-->
  <!--Calibration coefficients for ECAL-->
  <parameter name="CalibrECAL" type="FloatVec">31.3 83  </parameter>
  <!--Calibration coefficients for HCAL-->
  <parameter name="CalibrHCAL" type="FloatVec">27.3  </parameter>
  <!--ECAL Collection Names-->
  <parameter name="ECALCollections" type="StringVec" lcioInType="SimCalorimeterHit">ecal02_EcalBarrel ecal02_EcalEndcap  </parameter>
  <!--Index of ECal Layers-->
  <parameter name="ECALLayers" type="IntVec">30 100  </parameter>
  <!--ECAL Collection of real Hits-->
  <parameter name="ECALOutputCollection" type="string" lcioOutType="CalorimeterHit">ECAL </parameter>
  <!--Threshold for ECAL Hits in GeV-->
  <parameter name="ECALThreshold" type="float">1e-04 </parameter>
  <!--HCAL Collection Names-->
  <parameter name="HCALCollections" type="StringVec" lcioInType="SimCalorimeterHit">hcalFeScintillator_HcalBarrelEnd hcalFeScintillator_HcalBarrelReg hcalFeScintillator_HcalEndCaps  </parameter>
  <!--Index of HCal Layers-->
  <parameter name="HCALLayers" type="IntVec">100  </parameter>
  <!--HCAL Collection of real Hits-->
  <parameter name="HCALOutputCollection" type="string" lcioOutType="CalorimeterHit">HCAL </parameter>
  <!--Threshold for HCAL Hits in GeV-->
  <parameter name="HCALThreshold" type="float">0.0004 </parameter>
  <!--Digital Ecal-->
  <parameter name="IfDigitalEcal" type="int">0 </parameter>
  <!--Digital Hcal-->
  <parameter name="IfDigitalHcal" type="int">0 </parameter>
  <!--CaloHit Relation Collection-->
  <parameter name="RelationOutputCollection" type="string" lcioOutType="LCRelation">RelationCaloHit </parameter>
</processor>

 <processor name="MySimpleFastMCProcessor" type="SimpleFastMCProcessor">
 <!--SimpleFastMCProcessor creates ReconstrcutedParticles from MCParticles according to the resolution given in the steering file.-->
  <!--Resolution of charged particles in polar angle range:  d(1/P)  th_min  th_max-->
  <parameter name="ChargedResolution" type="FloatVec">5e-05 0 1.5708  </parameter>
  <!--Name of the MCParticle input collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="MCParticle">MCParticle </parameter>
  <!--Name of the MCTruthMapping output collection-->
  <parameter name="MCTruthMappingCollectionName" type="string" lcioOutType="LCRelation">MCTruthMapping </parameter>
  <!--No reconstructed particles are produced for smaller momenta (in [GeV])-->
  <parameter name="MomentumCut" type="float">0.001 </parameter>
  <!--Resolution dE/E=A+B/sqrt(E/GeV) of neutral hadrons in polar angle range: A  B th_min  th_max-->
  <parameter name="NeutralHadronResolution" type="FloatVec">0.04 0.5 0 1.5708  </parameter>
  <!--Resolution dE/E=A+B/sqrt(E/GeV) of photons in polar angle range: A  B th_min  th_max-->
  <parameter name="PhotonResolution" type="FloatVec">0.01 0.1 0 1.5708  </parameter>
  <!--Name of the ReconstructedParticles output collection-->
  <parameter name="RecoParticleCollectionName" type="string" lcioOutType="ReconstructedParticle">ReconstructedParticles </parameter>
</processor>

 <processor name="MySimpleLCalDigi" type="SimpleLCalDigi">
 <!--Performs simple digitization of sim lcal hits...-->
  <!--Calibration coefficients for LCAL-->
  <parameter name="CalibrLCAL" type="float">31 </parameter>
  <!--LCal Collection Names-->
  <parameter name="LCALCollections" type="StringVec" lcioInType="SimCalorimeterHit">SLcal01_LumiCal  </parameter>
  <!--LCal Collection of real Hits-->
  <parameter name="LCALOutputCollection" type="string" lcioOutType="CalorimeterHit">LCAL </parameter>
  <!--Threshold for LCal Hits in GeV-->
  <parameter name="LCalThreshold" type="float">0 </parameter>
  <!--CaloHit Relation Collection-->
  <parameter name="RelationOutputCollection" type="string" lcioOutType="LCRelation">RelationLCalHit </parameter>
</processor>

 <processor name="MySimpleMuonDigi" type="SimpleMuonDigi">
 <!--Performs simple digitization of sim muon hits...-->
  <!--Calibration coefficients for MUON-->
  <parameter name="CalibrMUON" type="float">31 </parameter>
  <!--Muon Collection Names-->
  <parameter name="MUONCollections" type="StringVec" lcioInType="SimCalorimeterHit">yoke03_MuonBarrel yoke03_MuonEndCap yoke03_MuonPlug  </parameter>
  <!--Muon Collection of real Hits-->
  <parameter name="MUONOutputCollection" type="string" lcioOutType="CalorimeterHit">MUON </parameter>
  <!--Threshold for Muon Hits in GeV-->
  <parameter name="MuonThreshold" type="float">0 </parameter>
  <!--CaloHit Relation Collection-->
  <parameter name="RelationOutputCollection" type="string" lcioOutType="LCRelation">RelationMuonHit </parameter>
</processor>

 <processor name="MySimpleTimer" type="SimpleTimer">
 <!--MARLIN Processor 'SimpleTimer', offers simple timer utilities-->
  <!--Mode-->
  <parameter name="Mode" type="int">0 </parameter>
  <!--Seconds to Wait-->
  <parameter name="SecondsToWait" type="int">0 </parameter>
</processor>

 <processor name="MySkipNEvents" type="SkipNEvents">
 <!--The output condition of this processor is false for the first n LCEvents. Afterwards it is set to true.-->
  <!--number of LCEvents to skip-->
  <parameter name="nSkip" type="int">0 </parameter>
</processor>

 <processor name="MySphere" type="Sphere">
 <!--Sphere calculates eigenvalues of sphericity tensor-->
  <!--Name of the ReconstructedParticle collection-->
  <parameter name="CollectionName" type="string" lcioInType="ReconstructedParticle">RecontructedParticle </parameter>
  <!--name of parameter to store the results -->
  <parameter name="eigenvalues_parameter_name" type="string">sphericity_tensor_eigenvalues </parameter>
  <!-- exponent in sphericity tensor use 2.0 for classical 1.0 for C,D-->
  <parameter name="r_value" type="float">2 </parameter>
</processor>

 <processor name="MyStdHepReader" type="StdHepReader">
 <!--Reads StdHep files as input and creates LCIO events with MCParticle collections. Make sure to not specify any LCIOInputFiles in the steering in order to read StdHep files.-->
  <!--input file-->
  <parameter name="StdHepFileName" type="string">input.stdhep </parameter>
</processor>

 <processor name="MyTPCDigiProcessor" type="TPCDigiProcessor">
 <!--Produces TPC TrackerHit collection from SimTrackerHit collection, smeared in RPhi and Z-->
  <!--Name of the SimTrackerHit collection-->
  <parameter name="CollectionName" type="string" lcioInType="SimTrackerHit">TPCCollection </parameter>
  <!--R-Phi Diffusion Coefficent in TPC-->
  <parameter name="DiffusionCoeffRPhi" type="float">0.025 </parameter>
  <!--Z Diffusion Coefficent in TPC-->
  <parameter name="DiffusionCoeffZ" type="float">0.08 </parameter>
  <!--Number of Effective electrons per pad in TPC-->
  <parameter name="N_eff" type="int">22 </parameter>
  <!--Defines spatial slice in RP-->
  <parameter name="PixRP" type="float">1 </parameter>
  <!--Defines spatial slice in Z-->
  <parameter name="PixZ" type="float">1.4 </parameter>
  <!--Pad Phi Resolution constant in TPC-->
  <parameter name="PointResolutionPadPhi" type="float">0.9 </parameter>
  <!--R-Phi Resolution constant in TPC-->
  <parameter name="PointResolutionRPhi" type="float">0.05 </parameter>
  <!--TPC Z Resolution Coefficent independent of diffusion-->
  <parameter name="PointResolutionZ" type="float">0.4 </parameter>
  <!--whether or not to use hits without proper cell ID (pad row)-->
  <parameter name="RejectCellID0" type="int">1 </parameter>
  <!--Name of the digitized TrackerHit collection-->
  <parameter name="TPCTrackerHitsCol" type="string" lcioOutType="TrackerHit">TPCTrackerHits </parameter>
</processor>

 <processor name="MyTPCElectronicsProcessor" type="TPCElectronicsProcessor">
 <!--TPCElectronicsProcessor takes care of binning the times and charge of electrons into an ADC.-->
  <!--Maximal Charge of ADC in number of electrons-->
  <parameter name="ADCMaxCharge" type="int">33500 </parameter>
  <!--Resolution of ADC in bit-->
  <parameter name="ADCResolution" type="int">8 </parameter>
  <!--Threshold for ADC in ADC bins-->
  <parameter name="ADCThreshold" type="int">5 </parameter>
  <!--Name of the Input collection with TPCPads-->
  <parameter name="CollectionName" type="string">TPCPads </parameter>
  <!--Name of the Input collection with drifted electrons-->
  <parameter name="CollectionName1" type="string">DriftedElectrons </parameter>
  <!--Name of the Input collection with primary ionisation-->
  <parameter name="CollectionName2" type="string">PrimaryIonisation </parameter>
  <!--Correction for gain due to temperature etc.-->
  <parameter name="GainFactor" type="double">1 </parameter>
  <!--Integration Cut Off of Gaussian Shape-->
  <parameter name="IntCutOff" type="double">3 </parameter>
  <!--Readout Frequency in Mhz-->
  <parameter name="ReadoutFrequency" type="float">12.5 </parameter>
  <!--Rise Time of Shaper in ns-->
  <parameter name="RiseTime" type="float">120 </parameter>
  <!--switch off writing of output collection-->
  <parameter name="Transient" type="int">0 </parameter>
</processor>

 <processor name="MyTPCHitToTrackerDataConverterProcessor" type="TPCHitToTrackerDataConverterProcessor">
 <!--TPCHitToTrackerDataConverterProcessor converts data in the (deprecated) TPCHit format to TrackerData. By setting the parameter IgnoreFirstNBins to a non-zero integer value N, the first N bins will be disregarded.-->
  <!--Number of bins at the beginning of the pulse that should not be stored-->
  <parameter name="IgnoreFirstNBins" type="int">0 </parameter>
  <!--Name of the input collection-->
  <parameter name="InputCollectionName" type="string">TPCFADC </parameter>
  <!--Name of the output collection-->
  <parameter name="OutputCollectionName" type="string">TPCConvertedRawData </parameter>
  <!--if not 0 the output collection is set transient-->
  <parameter name="SetOutputTransient" type="int">1 </parameter>
</processor>

 <processor name="MyTTBarExample" type="TTBarExample">
 <!--TTBarExample does a 6C fit on 6jet ttbar events (Px, Py, Pz, E, M12 = M34 = M_W (for all permutations assuming the b-jets are tagged))-->
  <!--Name of the B Jet collection-->
  <parameter name="BJetCollectionName" type="string" lcioInType="ReconstructedParticle">DurhamBJets </parameter>
  <!--Center-of-Mass Energy-->
  <parameter name="ECM" type="float">500 </parameter>
  <!--Name of the Light Jet collection-->
  <parameter name="LightJetCollectionName" type="string" lcioInType="ReconstructedParticle">DurhamLightJets </parameter>
</processor>

 <processor name="MyTestProcessor" type="TestProcessor">
 <!--Simple processor to test the marlin application. Prints run and event number.-->
</processor>

 <processor name="MyThrustReconstruction" type="ThrustReconstruction">
 <!--Calculates thrust axis and thrust value of event using different algorithms-->
  <!--Name of collection of reconstructed particles used for thrust reconstruction-->
  <parameter name="inputCollectionName" type="string" lcioInType="ReconstructedParticle">SelectedReconstructedParticle </parameter>
  <!--Type of thrust reconstruction algorithm to be used:
#	1 : Tasso algorithm
#	2 : JetSet algorithm-->
  <parameter name="typeOfThrustFinder" type="int">2 </parameter>
</processor>

 <processor name="MyTimePixClusterFinderProcessor" type="TimePixClusterFinderProcessor">
 <!--TimePixClusterFinderProcessor converts Trackerdata of TimePix into TrackerHits by arranging adjacent pixels to clusters-->
  <!--Name of the input collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="TrackerData">TimePixZeroSuppressedData </parameter>
  <!--Name of the output collection-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="TrackerHit">TimePixHitCandidates </parameter>
  <!--Name of the split  data collection-->
  <parameter name="OutputCollectionNameSplitData" type="string" lcioOutType="TrackerData">TimePixSplitData </parameter>
  <!--if not 0 the output collection is set transient-->
  <parameter name="SetOutputTransient" type="int">0 </parameter>
  <!--minimum number of pixels in one cluster-->
  <parameter name="minNoPixel" type="int">10 </parameter>
  <!--number of columns of the chip-->
  <parameter name="nColumn" type="int">256 </parameter>
  <!--number of rows of the chip-->
  <parameter name="nRow" type="int">256 </parameter>
</processor>

 <processor name="MyTimePixClusterProjectionSeparatorProcessor" type="TimePixClusterProjectionSeparatorProcessor">
 <!--TimePixClusterProjectionSeparatorProcessor further seperates the clusters found in the TimePixClusterFinderProcessor by projecting them onto their own axis-->
  <!--Name of the input collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="TrackerHit">TimePixHitCandidates </parameter>
  <!--Name of the mode map collection-->
  <parameter name="ModeMapCollectionName" type="string" lcioInType="LCGenericObject">TimePixModeMap </parameter>
  <!--Name of the collection containing the correction to the mode map collection-->
  <parameter name="ModeMapCorrCollectionName" type="string" lcioInType="LCGenericObject">TimePixModeMapCorr </parameter>
  <!--Name of the output collection-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="TrackerHit">TimePixSepHitCandidates </parameter>
  <!--if not 0 the output collection is set transient-->
  <parameter name="SetOutputTransient" type="int">0 </parameter>
  <!--number of pixels in a cluster in order for it to be seperated-->
  <parameter name="clusterSizeToSep" type="int">9 </parameter>
  <!--number of columns of the chip-->
  <parameter name="nColumn" type="int">256 </parameter>
  <!--number of rows of the chip-->
  <parameter name="nRow" type="int">256 </parameter>
</processor>

 <processor name="MyTimePixHighTOTAnalyserProcessor" type="TimePixHighTOTAnalyserProcessor">
 <!--TimePixHighTOTAnalyserProcessor eliminates extremely high TOT values due to a chip fault and replaces them by the arithmetic mean of the surrounding TOT values-->
  <!--Name of the raw data collection-->
  <parameter name="InoutCollectionName" type="string" lcioInType="TrackerRawData">TimePixRawData </parameter>
  <!--Name of the mode map collection-->
  <parameter name="ModeMapCollectionName" type="string" lcioInType="LCGenericObject">TimePixModeMap </parameter>
  <!--Number of columns of the chip -->
  <parameter name="NColumn" type="int">256 </parameter>
  <!--Number of rows of the chip -->
  <parameter name="NRow" type="int">256 </parameter>
  <!--Name of the HighTOT corrected mode map collection-->
  <parameter name="OutPutCollectionName" type="string" lcioOutType="LCGenericObject">TimePixModeMapCorr </parameter>
  <!--if not 0 the output collection is set transient-->
  <parameter name="SetOutputTransient" type="int">0 </parameter>
  <!--threshold on relation of TOT value to neighboring TOT values-->
  <parameter name="TOTThreshold" type="double">300 </parameter>
</processor>

 <processor name="MyTimePixHitCenterCalculatorProcessor" type="TimePixHitCenterCalculatorProcessor">
 <!--TimePixHitCenterCalculatorProcessor calculates the center of gravity of each cluster-->
  <!--drift velocity of gas in mm/s-->
  <parameter name="DriftVelocity" type="double">26.7 </parameter>
  <!--Name of the input collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="TrackerHit">TimePixSepHitCandidates </parameter>
  <!--Name of the mode map collection-->
  <parameter name="ModeMapCollectionName" type="string" lcioInType="LCGenericObject">TimePixModeMap </parameter>
  <!--Name of the collection containing the correction to the mode map-->
  <parameter name="ModeMapCorrCollectionName" type="string" lcioInType="LCGenericObject">TimePixModeMapCorr </parameter>
  <!--Name of the output collection-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="TrackerHit">TimePixHits </parameter>
  <!--readout frequency of TimePix chip in MHz-->
  <parameter name="ReadoutFrequency" type="double">100 </parameter>
  <!--if not 0 the output collection is set transient-->
  <parameter name="SetOutputTransient" type="int">0 </parameter>
  <!--length of shutter signal in s-->
  <parameter name="Shutter" type="double">108 </parameter>
  <!--number of columns of the chip-->
  <parameter name="nColumn" type="int">256 </parameter>
  <!--number of rows of the chip-->
  <parameter name="nRow" type="int">256 </parameter>
  <!--pitch of the chip in mm-->
  <parameter name="pitch" type="double">0.055 </parameter>
</processor>

 <processor name="MyTimePixHitSorterProcessor" type="TimePixHitSorterProcessor">
 <!--TimePixHitSorterProcessor sorts the TimePixHits in y,x,z (in that order) to be used in TrackFinderRectangularProcessor -->
  <!--Name of the input collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="TrackerHit">TimePixHits </parameter>
  <!--Name of the output collection-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="TrackerHit">TimePixSortedHits </parameter>
  <!--if not 0 the output collection is set transient-->
  <parameter name="SetOutputTransient" type="int">0 </parameter>
  <!--maximum value of time-->
  <parameter name="maxTime" type="int">11810 </parameter>
  <!--number of columns on the chip-->
  <parameter name="nColumn" type="int">256 </parameter>
  <!--number of rows on the chip-->
  <parameter name="nRow" type="int">256 </parameter>
  <!--pitch of the chip in mm-->
  <parameter name="pitch" type="double">0.055 </parameter>
</processor>

 <processor name="MyTimePixOccupancyProcessor" type="TimePixOccupancyProcessor">
 <!--TimePixOccupancyProcessor: Count how many times a pixel has been hit-->
  <!--Name of the input collection  with lcio::TrackerRawData (default: TimePixRawData)-->
  <parameter name="InputColName" type="string" lcioInType="TrackerRawData">TimePixRawData </parameter>
  <!--Number of colmns on the chip (default: 256)-->
  <parameter name="NColumns" type="int">256 </parameter>
  <!--Number of rows on the chip (default: 256)-->
  <parameter name="NRows" type="int">256 </parameter>
</processor>

 <processor name="MyTimePixReaderProcessor" type="TimePixReaderProcessor">
 <!-- description not set by author -->
  <!--ID number of the chip -->
  <parameter name="ChipID" type="int">0 </parameter>
  <!--Description of data-->
  <parameter name="Description" type="string">no description given </parameter>
  <!--Name of the detector-->
  <parameter name="DetectorName" type="string">TPC </parameter>
  <!--input file with list of TimePix files-->
  <parameter name="FileListName" type="string">TimePixData.txt </parameter>
  <!--_maxRecordN -->
  <parameter name="MaxRecordNumber" type="int">100000 </parameter>
  <!--Operation mode of the chip: TOT, TIME, MM1 (mixed mode with CellID0 =  TIME), MM2 (mixed mode with CellID0 =  TOT)-->
  <parameter name="Mode" type="string">TOT </parameter>
  <!--Name of the output mode map collection-->
  <parameter name="ModeMapCollectionName" type="string" lcioOutType="LCGenericObject">TimePixModeMap </parameter>
  <!--Number of columns on the chip -->
  <parameter name="NColumn" type="int">256 </parameter>
  <!--Number of rows on the chip -->
  <parameter name="NRow" type="int">256 </parameter>
  <!--Name of the output collection-->
  <parameter name="OutPutCollectionName" type="string" lcioOutType="TrackerRawData">TimePixRawData </parameter>
  <!--if not 0 the output collection is set transient-->
  <parameter name="SetOutputTransient" type="int">0 </parameter>
  <!--Name of the subdetector-->
  <parameter name="SubDetectorName" type="string">TimePix </parameter>
</processor>

 <processor name="MyTimePixZeroSuppressionProcessor" type="TimePixZeroSuppressionProcessor">
 <!--TimePixZeroSuppressionProcessor converts TrackerRawData of TimePix into zerosuppressed TrackerRawData by only keeping ADC values above a certain threshold-->
  <!--Name of the input collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="TrackerRawData">TimePixRawData </parameter>
  <!--Number of columns of the chip -->
  <parameter name="NColumn" type="int">256 </parameter>
  <!--Number of rows of the chip -->
  <parameter name="NRow" type="int">256 </parameter>
  <!--Name of the output collection-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="TrackerRawData">TimePixZeroSuppressedRawData </parameter>
  <!--if not 0 the output collection is set transient-->
  <parameter name="SetOutputTransient" type="int">0 </parameter>
  <!--Throw SkipEventException if TimePix data is empty-->
  <parameter name="SkipEmptyEvents" type="int">1 </parameter>
  <!--Threshold on the TOT value of a single pixel -->
  <parameter name="TOTThreshold" type="double">0 </parameter>
</processor>

 <processor name="MyTrackBasedPFlow" type="TrackBasedPFlow">
 <!--simple track-based particle flow processor-->
  <!--limits the amount of information written to std out (0 - none, 9 - maximal information)-->
  <parameter name="DebugLevel" type="int">0 </parameter>
  <!--Display Info on Clusters-->
  <parameter name="DisplayClusterInfo" type="int">0 </parameter>
  <!--Distance to Define Direction-->
  <parameter name="DistanceForDirection" type="float">1 </parameter>
  <!--Distance To Merge Forward-->
  <parameter name="DistanceMergeForward" type="FloatVec">50 100  </parameter>
  <!--Distance to Track Seed-->
  <parameter name="DistanceToTrackSeed" type="float">25 </parameter>
  <!--Distance to Track Back -->
  <parameter name="DistanceTrackBack" type="FloatVec">50 100  </parameter>
  <!--merging clusters forward-wise?-->
  <parameter name="DoMergingForward" type="int">0 </parameter>
  <!--merging low multiplicity clusters?-->
  <parameter name="DoMergingLowMultiplicity" type="int">1 </parameter>
  <!--draw objects on CED-->
  <parameter name="DrawOnCED" type="int">0 </parameter>
  <!--Coefficients for the MIP calibration in the ECAL in GeV/MIP-->
  <parameter name="MIPCoeffEcal" type="FloatVec">0.007 0.022  </parameter>
  <!--Coefficients for the MIP calibration in the HCAL in GeV/MIP-->
  <parameter name="MIPCoeffHcal" type="FloatVec">0.03  </parameter>
  <!--Maximal Hits To Merge-->
  <parameter name="MaximalHitsToMerge" type="int">50 </parameter>
  <!--Minimal allowed hits in cluster-->
  <parameter name="MinimalHitsInCluster" type="int">3 </parameter>
  <!--Minimal neutral hits allowed in cluster-->
  <parameter name="MinimalNeutralHitsInCluster" type="int">3 </parameter>
  <!--N hits scan to merge forward -->
  <parameter name="NScanToMergeForward" type="int">40 </parameter>
  <!--N hits to define SP -->
  <parameter name="NToDefineSP" type="int">3 </parameter>
  <!--Resolution Parameter -->
  <parameter name="ResolutionParameter" type="FloatVec">20 60  </parameter>
  <!--Resolution Parameter for neutral particles-->
  <parameter name="ResolutionParameterForNeutrals" type="FloatVec">30 100  </parameter>
  <!--Resolution To Merge Halo Hits-->
  <parameter name="ResolutionToMerge" type="float">400 </parameter>
  <!--Step to Track Back -->
  <parameter name="StepTrackBack" type="FloatVec">40 160  </parameter>
  <!--Type of Generic Distance -->
  <parameter name="TypeOfGenericDistance" type="int">2 </parameter>
  <!--Type of Generic Distance for neutral particles-->
  <parameter name="TypeOfGenericDistanceForNeutrals" type="int">1 </parameter>
  <!--Use tracks to seed clusters-->
  <parameter name="UseTracking" type="int">0 </parameter>
  <!--Weight For Distance-->
  <parameter name="WeightForDistance" type="float">5 </parameter>
  <!--Weight For Distance for Neutrals-->
  <parameter name="WeightForDistanceForNeutrals" type="float">1 </parameter>
  <!--Weight For Resolution-->
  <parameter name="WeightForResolution" type="float">4 </parameter>
  <!--Weight For Resolution for Neutrals-->
  <parameter name="WeightForResolutionForNeutrals" type="float">1 </parameter>
  <!--cut on d0 of the tracks, use only tracks with d0 smaller than cut (in mm)-->
  <parameter name="absD0Cut" type="double">5 </parameter>
  <!--cut on z0 of the tracks, use only tracks with z0 smaller than cut (in mm))-->
  <parameter name="absZ0Cut" type="double">5 </parameter>
  <!--Calibration coefficients for ECAL-->
  <parameter name="calibrCoeffECAL" type="FloatVec">33.0235 93.5682  </parameter>
  <!--Calibration coefficients for HCAL-->
  <parameter name="calibrCoeffHCAL" type="FloatVec">21.1963  </parameter>
  <!--ECAL Collection Name-->
  <parameter name="colNameECAL" type="string">ECAL </parameter>
  <!--collection name of candidates of EM showers in the ECAL-->
  <parameter name="colNameEMShowerCandidates" type="string">EMShowerCandidates </parameter>
  <!--HCAL Collection Name-->
  <parameter name="colNameHCAL" type="string">HCAL </parameter>
  <!--name of the LC Relation collection between Calorimeterhits and SimCalorimeterhits-->
  <parameter name="colNameRelationCaloHitToSimCaloHit" type="string">RelationCaloHit </parameter>
  <!--name of the LC Relation collection between Tracks and MC particles-->
  <parameter name="colNameRelationTrackToMCP" type="string">TrackToMCP </parameter>
  <!--name of the Track collection-->
  <parameter name="colNameTracks" type="string">Tracks </parameter>
  <!--cut on pt, use only tracks with pt larger than cut (in GeV)-->
  <parameter name="cutOnPt" type="double">0.1 </parameter>
  <!--fraction of EM Energy-->
  <parameter name="fractionEM" type="double">0.95 </parameter>
  <!--maximal length of the cone-like tube around the track extrapolation where calorimeter hits around are taken into account-->
  <parameter name="maximalConeTubeLength" type="double">4000 </parameter>
  <!--maximal distance of electron shower position to extrapolated track-->
  <parameter name="maximalDistanceOfElectronShowerPosition" type="FloatVec">20 25  </parameter>
  <!--maximal distance to the extrapolated helix of the Calorimeter hit with the smallest 3-dim distance to MIP stub (in 4 zones)-->
  <parameter name="maximalDistanceToHelixToAssignCluster" type="FloatVec">200 50 60 80  </parameter>
  <!--maximal path length on the extrapolated helix for calorimeter hits to be taken into account as contributors to the MIP like stub-->
  <parameter name="maximalPathLengthForMIPLikeStub" type="double">4000 </parameter>
  <!--maximal radius of an inner cylindrical tube around the extralpolated helix for Calorimeter hits to be assigned as MIP like stub (in 3 zones)-->
  <parameter name="maximalRadiusOfInnerTubeForMIPLikeStub" type="FloatVec">15 17 40  </parameter>
  <!--cut on minimal number of non TPC hits, use only tracks with more non TPC tracker hits than cut for the tracks which were not extrapolated-->
  <parameter name="minNNonTPCHits" type="int">1 </parameter>
  <!--cut on minimal number of TPC hits, use only tracks with more TPC tracker hits than cut for the tracks which were not extrapolated-->
  <parameter name="minNTPCHits" type="int">5 </parameter>
  <!--minimal radius of an outer cylindrical tube around the extralpolated helix for Calorimeter hits to be excluded as MIP like stub (in 3 zones)-->
  <parameter name="minimalRadiusOfOuterTubeForMIPLikeStub" type="FloatVec">40 45 110  </parameter>
  <!--number of Tracker hits (as a subset of nOfTrackerHitsUsedForExtrapolation) which are located outside cylindrical cut-->
  <parameter name="nOfTrackerHitsOutsideCylindricalCut" type="int">25 </parameter>
  <!--number of outermost Tracker hits used for the extrapolation of the track into the calorimeter-->
  <parameter name="nOfTrackerHitsUsedForExtrapolation" type="int">90 </parameter>
  <!--opening angle (in degree) of the cone-like tube around the track extrapolation (only calorimeter hits insider this tube are taken into account)-->
  <parameter name="openingAngleConeTube" type="double">120 </parameter>
  <!--sets processor output condition 'to true' if fabs(a) >= 'outputConditionLimit' (where a is a/sqrt(E)), otherwise 'false'-->
  <parameter name="outputConditionLimit" type="double">1 </parameter>
  <!--cut on the maximal radius of the outermost tracker hit, should be something like tpcInnerRadius plus 20%-->
  <parameter name="rMaxOfOuterMostTrackerHit" type="double">400 </parameter>
  <!--cut on the minimal radius of the tracker hits to be taken into account in the helix extrapolation (in cylindrical coordinates)-->
  <parameter name="rMinCutHelixExtrapolation" type="double">600 </parameter>
  <!--cut on the minimal radius of the 'nOfTrackerHitsOutsideCylindricalCut' tracker hits-->
  <parameter name="rMinCylindricalCut" type="double">800 </parameter>
  <!--name of the collection of clusters assigned to the reconstructed particles-->
  <parameter name="reconstructedClusterCollectionName" type="string">ClustersFromTrackBasedPFlow </parameter>
  <!--name of the collection of reconstructed particles-->
  <parameter name="reconstructedParticleCollectionName" type="string">RecoParticlesFromTrackBasedPFlow </parameter>
  <!--cut on the minimal z coordiante of the tracker hits to be taken into account in the helix extrapolation (in cylindrical coordinates)-->
  <parameter name="zMinCutHelixExtrapolation" type="double">900 </parameter>
  <!--cut on the minimal z coordiante of the 'nOfTrackerHitsOutsideCylindricalCut' tracker hits-->
  <parameter name="zMinCylindricalCut" type="double">1300 </parameter>
</processor>

 <processor name="MyTrackCheater" type="TrackCheater">
 <!--Creates true tracks...-->
  <!--Cut On Fit Chi2-->
  <parameter name="Chi2Cut" type="float">100 </parameter>
  <!--Cut on d0 to accept track-->
  <parameter name="CutOnD0" type="float">500 </parameter>
  <!--Cut on TPC hits for tracks with no Si hits-->
  <parameter name="CutOnTPCHits" type="int">35 </parameter>
  <!--Cut on Z0 to accept track-->
  <parameter name="CutOnZ0" type="float">500 </parameter>
  <!--Level of the printout info for the debuging purposes-->
  <parameter name="Debug" type="int">1 </parameter>
  <!--Energy Cut-->
  <parameter name="ECut" type="float">0.1 </parameter>
  <!--Flag to Fit True Track-->
  <parameter name="FitTrueTrack" type="int">1 </parameter>
  <!--Cut on distance from hit to helix-->
  <parameter name="HitToHelixDist" type="float">500 </parameter>
  <!--Cut on distance from hit to helix in fitting-->
  <parameter name="HitToHelixInFit" type="float">20 </parameter>
  <!--Name of the TrueTrack MC Relation collection-->
  <parameter name="MCTrueTrackRelCollectionName" type="string" lcioOutType="LCRelation">TrueTracksMCP </parameter>
  <!--Minimal Hits in Track Cluster-->
  <parameter name="MinimalHits" type="int">3 </parameter>
  <!--Track Fit Option-->
  <parameter name="OptFit" type="int">4 </parameter>
  <!--Store only hits used in fit?-->
  <parameter name="StoreHitsInFit" type="int">0 </parameter>
  <!--Tracker Hit Collection Names-->
  <parameter name="TrackerHitCollections" type="StringVec" lcioInType="TrackerHit">VTXTrackerHits FTDTrackerHits SITTrackerHits TPCTrackerHits  </parameter>
  <!--Collection of True Clusters-->
  <parameter name="TrueTrackCollection" type="string" lcioOutType="Track">TrueTracks </parameter>
  <!--Use Extra Point in Fit?-->
  <parameter name="UseExtraPoint" type="int">0 </parameter>
  <!--Parameter a to define minimal IP error-->
  <parameter name="aParameterForIPError" type="float">0.002 </parameter>
  <!--Parameter b to define minimal IP error-->
  <parameter name="bParameterForIPError" type="float">0.0076 </parameter>
  <!--Parameter s to define minimal IP error-->
  <parameter name="sParameterForIPError" type="float">0.75 </parameter>
</processor>

 <processor name="MyTrackFinderHoughTrafoProcessor" type="TrackFinderHoughTrafoProcessor">
 <!--TrackFinderHoughTrafoProcessor uses the hough transformation to find hits on track, track parameters can be used as starting values for the TrackFitter-->
  <!--Name of the input collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="TrackerHit">TimePixHits </parameter>
  <!--Maximum distance of a hit to the track in mm-->
  <parameter name="MaximumDistanceToTrack" type="double">0.5 </parameter>
  <!--minimum number of hits on one track-->
  <parameter name="NHitsOnTrack" type="int">5 </parameter>
  <!--Name of the output collection-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="Track">TimePixTrackCandidates </parameter>
  <!--the pitch of the chip in mm-->
  <parameter name="Pitch" type="double">0.055 </parameter>
  <!--if not 0 the output collection is set transient-->
  <parameter name="SetOutputTransient" type="int">0 </parameter>
  <!--Type of track that is looked for-->
  <parameter name="TrackType" type="string">StraightLine </parameter>
</processor>

 <processor name="MyTrackFinderRectangularProcessor" type="TrackFinderRectangularProcessor">
 <!--TrackFinderRectangularProcessor searches straight tracks using linear regression-->
  <!--Maximum distance of predicted and measured hit in x in mm-->
  <parameter name="DeltaX" type="float">3 </parameter>
  <!--Maximum distance of predicted and measured hit in y in mm-->
  <parameter name="DeltaY" type="float">0.01 </parameter>
  <!--Maximum distance of predicted and measured hit in z in ns-->
  <parameter name="DeltaZ" type="float">500 </parameter>
  <!--Name of the input collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="TrackerHit">TPCHits </parameter>
  <!--Maximum number of subsequnetly missing hits-->
  <parameter name="MaxSkipRows" type="int">1 </parameter>
  <!--Minimum number of hits on track-->
  <parameter name="MinTrackHits" type="int">5 </parameter>
  <!--Name of the output collection-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="Track"> TPCSeedTracks </parameter>
  <!--if not 0 the output collection is set transient-->
  <parameter name="SetOutputTransient" type="int">0 </parameter>
  <!--Level of prozessor verbosity (0 .. 5)-->
  <parameter name="VerboseLevel" type="int">1 </parameter>
</processor>

 <processor name="MyTrackFitterLikelihoodProcessor" type="TrackFitterLikelihoodProcessor">
 <!--Fits a Likely Track to the signals collected on the readout geometry.-->
  <!--The diffusion of the gas in the TPC (FIXME - check units)-->
  <parameter name="DiffusionConstant" type="double">0 </parameter>
  <!--Controls whether the minimization should try and fit Sigma0 as a free parameter (true) or leave it as a constant (false - default)-->
  <parameter name="FitSigma0?" type="bool">false </parameter>
  <!--A name for the collection the fitted track will be stored with.-->
  <!--parameter name="FittedTrackCollection" type="string">TPCTracks </parameter-->
  <!--A parameter to reduce the affect of spurious signals.-->
  <parameter name="Noise" type="double">0.01 </parameter>
  <!--The name of the Seed Track collection.-->
  <!--parameter name="SeedTrackCollection" type="string">TPCSeedTracks </parameter-->
  <!--The constant diffusion for each electron cloud in the TPC-->
  <parameter name="Sigma0" type="double">0.5 </parameter>
  <!--The standard deviation of the primary ionizations in the z direction (mm)-->
  <parameter name="SigmaZ" type="double">0 </parameter>
  <!--Name of the collection containing the TPC conditions-->
  <!--parameter name="TPCConditionsCollection" type="string">TPCConditions </parameter-->
</processor>

 <processor name="MyTrackSeederProcessor" type="TrackSeederProcessor">
 <!--Calculates seed track parameters from  in the TrackerHits in the track candidates collection!-->
  <!--The the name of the input collection of track candidates (default: TPCTrackCandidates)-->
  <parameter name="InputTrackCandidates" type="string" lcioInType="Track">TPCTrackCandidates </parameter>
  <!--The name of the collection the seed tracks be stored under (default: TPCSeedTracks)-->
  <parameter name="OutputSeedTracks" type="string" lcioOutType="Track">TPCSeedTracks </parameter>
  <!--if not 0 the output hits collection is set transient (default: 0)-->
  <parameter name="SetOutputTransient" type="int">0 </parameter>
</processor>

 <processor name="MyTrackerRawDataToDataConverterProcessor" type="TrackerRawDataToDataConverterProcessor">
 <!--TrackerRawDataToDataConverterProcessor converts the TrackerRawData to TrackerData without processing the values-->
  <!--Name of the input collection-->
  <parameter name="InputCollectionName" type="string" lcioInType="TrackerRawData">TPCRawData </parameter>
  <!--Name of the output collection-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="TrackerData">TPCConvertedRawData </parameter>
  <!--if not 0 the output collection is set transient-->
  <parameter name="SetOutputTransient" type="int">1 </parameter>
</processor>

 <processor name="MyTrackwiseClustering" type="TrackwiseClustering">
 <!--Performs clustering in a track-wise manner...-->
  <!--Magnetic Field (in TESLA)-->
  <parameter name="BField" type="float">4 </parameter>
  <!--Cluster Collection Name -->
  <parameter name="ClusterCollection" type="string" lcioOutType="Cluster">ClustersAR </parameter>
  <!--Display Info on Clusters-->
  <parameter name="DisplayClusterInfo" type="int">0 </parameter>
  <!--Distance to Define Direction-->
  <parameter name="DistanceForDirection" type="float">5 </parameter>
  <!--Distance To Merge Forward-->
  <parameter name="DistanceMergeForward" type="FloatVec">50 100  </parameter>
  <!--Distance to Track Seed-->
  <parameter name="DistanceToTrackSeed" type="float">25 </parameter>
  <!--Distance to Track Back -->
  <parameter name="DistanceTrackBack" type="FloatVec">100 500  </parameter>
  <!--merging clusters forward-wise?-->
  <parameter name="DoMergingForward" type="int">1 </parameter>
  <!--merging low multiplicity clusters?-->
  <parameter name="DoMergingLowMultiplicity" type="int">1 </parameter>
  <!--Ecal Collection Names -->
  <parameter name="EcalCollections" type="StringVec" lcioInType="CalorimeterHit">ECAL  </parameter>
  <!--Hcal Collection Names -->
  <parameter name="HcalCollections" type="StringVec" lcioInType="CalorimeterHit">HCAL  </parameter>
  <!--Maximal Hits To Merge-->
  <parameter name="MaximalHitsToMerge" type="int">50 </parameter>
  <!--Minimal allowed hits in cluster-->
  <parameter name="MinimalHitsInCluster" type="int">10 </parameter>
  <!--N hits scan to merge forward -->
  <parameter name="NScanToMergeForward" type="int">10 </parameter>
  <!--N hits to define SP -->
  <parameter name="NToDefineSP" type="int">5 </parameter>
  <!--Resolution Parameter -->
  <parameter name="ResolutionParameter" type="FloatVec">20 80  </parameter>
  <!--Resolution To Merge Halo Hits-->
  <parameter name="ResolutionToMerge" type="float">400 </parameter>
  <!--Step to Track Back -->
  <parameter name="StepTrackBack" type="FloatVec">10 100  </parameter>
  <!--Track Collection Names -->
  <parameter name="TrackCollections" type="StringVec" lcioInType="Track">Track  </parameter>
  <!--Type of Generic Distance -->
  <parameter name="TypeOfGenericDistance" type="int">0 </parameter>
  <!--Use tracks to seed clusters-->
  <parameter name="UseTracking" type="int">0 </parameter>
  <!--Weight For Distance-->
  <parameter name="WeightForDistance" type="float">1 </parameter>
  <!--Weight For Resolution-->
  <parameter name="WeightForResolution" type="float">1 </parameter>
</processor>

 <processor name="MyTrueAngularJetFlavourProcessor" type="TrueAngularJetFlavourProcessor">
 <!--TrueAngularJetFlavourProcessor - Determines the true flavour of a jet from the MC Paticles associated to the Jets RP-->
  <!--Name of the ReconstructedParticle collection that represents jets-->
  <parameter name="JetRPCollection" type="string" lcioInType="ReconstructedParticle">Jets </parameter>
  <!--Name of the collection that holds all MC particles. -->
  <parameter name="MCParticleCollection" type="string" lcioInType="MCParticle">MCParticle </parameter>
  <!--Maximum value allowed between MCParticle and jet momentum expressed in degrees-->
  <!--parameter name="MaximumAngle" type="double">180 </parameter-->
  <!--Name of the output collection of LCIntVec (same order as jets)-->
  <parameter name="TrueJetFlavourCollection" type="string" lcioOutType="LCFloatVec">TrueJetFlavour </parameter>
</processor>

 <processor name="MyV0Finder" type="V0Finder">
 <!--V0 Finder Processor -->
  <!--Cuts on V0 radius-->
  <parameter name="CutOnRadius" type="float">5 </parameter>
  <!--Cut on two track distance-->
  <parameter name="CutOnTrkDistance" type="float">1.5 </parameter>
  <!--Maximal deviation in mass for photon candidate-->
  <parameter name="MassRangeGamma" type="float">0.01 </parameter>
  <!--Maximal deviation in mass for K0S candidate-->
  <parameter name="MassRangeK0S" type="float">0.01 </parameter>
  <!--Maximal deviation in mass for Lamda0 candidate-->
  <parameter name="MassRangeL0" type="float">0.008 </parameter>
  <!--Name of output collection of reconstructed particles-->
  <parameter name="RecoParticleCollection" type="string" lcioOutType="ReconstructedParticle">V0RecoParticles </parameter>
  <!--Name of input collection of reconstructed particles-->
  <parameter name="TrackCollection" type="string" lcioInType="Track">LDCTracks </parameter>
  <!--Name of output collection of neutral vertices-->
  <parameter name="VertexCollection" type="string" lcioOutType="Vertex">V0Vertices </parameter>
</processor>

 <processor name="MyV0Performance" type="V0Performance">
 <!--V0Performance processor does performance analysis of conversion and V0 tagging-->
  <!--names of LCCollections to print statistics for-->
  <!--parameter name="collectionsToPrint" type="StringVec"> </parameter-->
  <!--minimum hit numbers for conv/V0 decay particles-->
  <!--parameter name="minHits" type="int">-999 </parameter-->
</processor>

 <processor name="MyVTXDigiProcessor" type="VTXDigiProcessor">
 <!--VTXDigiProcessor should create VTX TrackerHits from SimTrackerHits-->
  <!--Debugging option-->
  <parameter name="Debug" type="int">0 </parameter>
  <!--Momentum Cut For D Rays (MeV)-->
  <parameter name="MomentumCutForDRays" type="float">10 </parameter>
  <!--R-Phi Resolution in SET-->
  <parameter name="PointResolutionRPhi_SET" type="float">0.01 </parameter>
  <!--R-Phi Resolution in SIT-->
  <parameter name="PointResolutionRPhi_SIT" type="float">0.01 </parameter>
  <!--R-Phi Resolution in VTX-->
  <parameter name="PointResolutionRPhi_VTX" type="float">0.004 </parameter>
  <!--Z Resolution in SET-->
  <parameter name="PointResolutionZ_SET" type="float">0.01 </parameter>
  <!--Z Resolution in SIT-->
  <parameter name="PointResolutionZ_SIT" type="float">0.01 </parameter>
  <!--Z Resolution in VTX-->
  <parameter name="PointResolutionZ_VTX" type="float">0.004 </parameter>
  <!--Remove D-rays ?-->
  <parameter name="RemoveDrays" type="int">0 </parameter>
  <!--Name of the SET SimTrackerHit collection-->
  <parameter name="SETCollectionName" type="string" lcioInType="SimTrackerHit">SETCollection </parameter>
  <!--Name of the set TrackerHit output collection-->
  <parameter name="SETHitCollection" type="string" lcioOutType="TrackerHit">SETTrackerHits </parameter>
  <!--Name of the SIT SimTrackerHit collection-->
  <parameter name="SITCollectionName" type="string" lcioInType="SimTrackerHit">SITCollection </parameter>
  <!--Name of the sit TrackerHit output collection-->
  <parameter name="SITHitCollection" type="string" lcioOutType="TrackerHit">SITTrackerHits </parameter>
  <!--Name of the VTX SimTrackerHit collection-->
  <parameter name="VTXCollectionName" type="string" lcioInType="SimTrackerHit">VXDCollection </parameter>
  <!--Name of the vxd TrackerHit output collection-->
  <parameter name="VTXHitCollection" type="string" lcioOutType="TrackerHit">VTXTrackerHits </parameter>
</processor>

 <processor name="MyVTXDigitizer" type="VTXDigitizer">
 <!--VTXDigitizer should create VTX TrackerHits from SimTrackerHits-->
  <!--Additional Collections to store hit position in the local ladder frame-->
  <parameter name="AdditionalCollections" type="int">0 </parameter>
  <!--Background Hits per Layer-->
  <parameter name="BackgroundHitsPerLayer" type="FloatVec">34400 23900 9600 5500 3100  </parameter>
  <!--Name of the SimTrackerHit collection-->
  <parameter name="CollectionName" type="string" lcioInType="SimTrackerHit">vxd01_VXD </parameter>
  <!--Cut on delta-ray energy (MeV)-->
  <parameter name="CutOnDeltaRays" type="double">0.03 </parameter>
  <!--Debug option-->
  <parameter name="Debug" type="int">0 </parameter>
  <!--Diffusion coefficient (in mm) for layer thickness-->
  <parameter name="Diffusion" type="double">0.002 </parameter>
  <!--Apply Electronic Effects-->
  <parameter name="ElectronicEffects" type="int">1 </parameter>
  <!--electronic noise in electrons-->
  <parameter name="ElectronicNoise" type="double">100 </parameter>
  <!--Electrons per keV-->
  <parameter name="ElectronsPerKeV" type="double">270.3 </parameter>
  <!--Energy Loss keV/mm-->
  <parameter name="EnergyLoss" type="double">280 </parameter>
  <!--Generate Background-->
  <parameter name="GenerateBackground" type="int">0 </parameter>
  <!--Name of the output TrackerHit collection-->
  <parameter name="OutputCollectionName" type="string" lcioOutType="TrackerHit">VTXTrackerHits </parameter>
  <!--Pixel Size X-->
  <parameter name="PixelSizeX" type="double">0.025 </parameter>
  <!--Pixel Size Y-->
  <parameter name="PixelSizeY" type="double">0.025 </parameter>
  <!--Apply Poisson smearing of electrons collected on pixels-->
  <parameter name="PoissonSmearing" type="int">1 </parameter>
  <!--Name of the output VTX trackerhit relation collection-->
  <parameter name="RelationColName" type="string" lcioOutType="LCRelation">VTXRelation </parameter>
  <!--Remove D-Ray Pixels-->
  <parameter name="RemoveDRayPixels" type="int">1 </parameter>
  <!--Segment Length-->
  <parameter name="SegmentLength" type="double">0.005 </parameter>
  <!--Tangent of Lorentz Angle-->
  <parameter name="TanLorentz" type="double">0.8 </parameter>
  <!--Cell Threshold in electrons-->
  <parameter name="Threshold" type="double">200 </parameter>
  <!--Use Particle Momentum-->
  <parameter name="UseMCPMomentum" type="int">1 </parameter>
  <!--Width of cluster-->
  <parameter name="WidthOfCluster" type="double">3 </parameter>
</processor>

 <processor name="MyVTXNoiseHits" type="VTXNoiseHits">
 <!--VTXNoiseHits should create VTX TrackerHits from SimTrackerHits-->
  <!--hit densities (hits/cm^2) per VXD layer-->
  <parameter name="HitDensityPerLayer_VTX" type="FloatVec">0 0 0 0 0  </parameter>
  <!--R-Phi Resolution in VTX-->
  <parameter name="PointResolutionRPhi_VTX" type="float">0.0027 </parameter>
  <!--Z Resolution in VTX-->
  <parameter name="PointResolutionZ_VTX" type="float">0.0027 </parameter>
  <!--Name of the VTX TrackerHit collection-->
  <parameter name="VTXCollectionName" type="string" lcioInType="TrackerHit">VTXTrackerHits </parameter>
</processor>

 <processor name="MyVertexChargeProcessor" type="VertexChargeProcessor">
 <!--VertexChargeProcessor - takes a set of vertices as a decay chain with its associated jet and calculates the vertex charge.-->
  <!--Parameter determining whether all tracks from secondary are included in the B-Charge-->
  <!--parameter name="ChargeAllSecondaryTracks" type="bool">true </parameter-->
  <!--Upper cut on track distance of closest approach to the seed axis for the B-Charge -->
  <!--parameter name="ChargeCloseapproachCut" type="double">1 </parameter-->
  <!--Cut determining the maximum L/D for the B-Charge-->
  <!--parameter name="ChargeLoDCutmax" type="double">2.5 </parameter-->
  <!--Cut determining the minimum L/D for the B-Charge-->
  <!--parameter name="ChargeLoDCutmin" type="double">0.18 </parameter-->
  <!--Name of the ReconstructedParticle collection that represents decay chains-->
  <parameter name="DecayChainRPCollection" type="string" lcioInType="ReconstructedParticle">DecayChains </parameter>
  <!--Name of the Vertex collection that contains the primary vertex (Optional)-->
  <parameter name="IPVertexCollection" type="string" lcioInType="Vertex">IPVertex </parameter>
  <!--Name of the ReconstructedParticle collection that represents jets-->
  <parameter name="JetRPCollection" type="string" lcioInType="ReconstructedParticle">Jets </parameter>
  <!--Name of the LCFloatVec Collection that will be created to contain the flavour tag inputs-->
  <parameter name="VertexChargeCollection" type="string" lcioOutType="LCFloatVec">BCharge </parameter>
</processor>

 <processor name="MyVertexViewer" type="VertexViewer">
 <!--Vertex Drawing Utility-->
  <!--Cut On D0-->
  <parameter name="CutOnD0" type="float">1e+20 </parameter>
  <!--Cut On Z0-->
  <parameter name="CutOnZ0" type="float">1e+20 </parameter>
  <!--Layer for SimCalorimeterHits-->
  <parameter name="LayerSimCalorimeterHits" type="int">-1 </parameter>
  <!--Layer for TrackerHits-->
  <parameter name="LayerTrackerHits" type="int">-1 </parameter>
  <!--Layer for Tracks-->
  <parameter name="LayerTracks" type="int">-1 </parameter>
  <!--Layer for True Tracks-->
  <parameter name="LayerTrueTracks" type="int">-1 </parameter>
  <!--SimCalorimeterHit Collection Name-->
  <parameter name="SimCalorimeterHitCollection" type="StringVec" lcioInType="SimCalorimeterHit">SEcal01_EcalBarrel SEcal01_EcalEndcap  </parameter>
  <!--Track Collection Name-->
  <parameter name="TrackCollection" type="string" lcioInType="Track">SiTracks </parameter>
  <!--Track MCP Rel Collection Name-->
  <parameter name="TrackMCPRelCollection" type="string" lcioInType="LCRelation">SiTracksMCP </parameter>
  <!--TrackerHit Collection Name-->
  <parameter name="TrackerHitCollection" type="StringVec" lcioInType="TrackerHit">VTXTrackerHits FTDTrackerHits  </parameter>
  <!--True Track Collection Name-->
  <parameter name="TrueTrackCollection" type="string" lcioInType="Track">TrueTracks </parameter>
  <!--True Track MCP Relation Collection Name-->
  <parameter name="TrueTrackMCPRelCollection" type="string" lcioInType="LCRelation">TrueTracksMCP </parameter>
</processor>

 <processor name="MyWW5CFit" type="WW5CFit">
 <!--WW5CFit does a 5C fit on 4 jet events (Px, Py, Pz, E, M12 = M34 (for all three permutations))-->
  <!--Center-of-Mass Energy-->
  <parameter name="ECM" type="float">500 </parameter>
  <!--Name of the Jet collection-->
  <parameter name="JetCollectionName" type="string" lcioInType="ReconstructedParticle">Durham2Jets </parameter>
</processor>

 <processor name="MyWolf" type="Wolf">
 <!--Particle Reconstruction-->
  <!--Cluster Collection Name-->
  <parameter name="ClusterCollection" type="string" lcioInType="Cluster">ClustersAR </parameter>
  <!--Dist Merge Cut-->
  <parameter name="DistMergeCut" type="float">150 </parameter>
  <!--Distance from Track Seed to Cluster-->
  <parameter name="DistanceTrackToCluster" type="float">50 </parameter>
  <!--Fraction of EM Energy-->
  <parameter name="FractionEM" type="float">0.95 </parameter>
  <!--Hcal Resolution-->
  <parameter name="HcalResolution" type="float">0.5 </parameter>
  <!--Lower Momentum-->
  <parameter name="LowerMomentum" type="float">5 </parameter>
  <!--Merge Clusters-->
  <parameter name="MergeClusters" type="int">1 </parameter>
  <!--Hits used in extrapolation-->
  <parameter name="NHitsInFit" type="int">40 </parameter>
  <!--Native Track Fitter-->
  <parameter name="NativeTrackFitter" type="int">0 </parameter>
  <!--Particle Collection Name-->
  <parameter name="ParticleCollection" type="string" lcioOutType="ReconstructedParticle">RecoParticles </parameter>
  <!--Cut on D0 for tracks-->
  <parameter name="RPhiCut" type="float">50 </parameter>
  <!--Track Collection Name-->
  <parameter name="TrackCollection" type="string" lcioInType="Track">TPCTracks </parameter>
  <!--Cut on Z0 for tracks-->
  <parameter name="ZCut" type="float">50 </parameter>
</processor>

 <processor name="MyXYZDistributionProcessor" type="XYZDistributionProcessor">
 <!--XYZDistributionProcessor: Fill x, y, and z distribution of all hits into AIDA histgram-->
  <!--Maximal value in x histogram (default:  15. mm)-->
  <parameter name="HistogramMaxValueX" type="float">15 </parameter>
  <!--Maximal value in y histogram (default:  15. mm)-->
  <parameter name="HistogramMaxValueY" type="float">15 </parameter>
  <!--Maximal value in z histogram (default:  260.0 mm)-->
  <parameter name="HistogramMaxValueZ" type="float">260 </parameter>
  <!--Minimum value in x histogram (default: 0. mm)-->
  <parameter name="HistogramMinValueX" type="float">0 </parameter>
  <!--Minimum value in y histogram (default: 0. mm)-->
  <parameter name="HistogramMinValueY" type="float">0 </parameter>
  <!--Minimum value in z histogram (default: 0.0 mm)-->
  <parameter name="HistogramMinValueZ" type="float">0 </parameter>
  <!--Name of the input hits collection-->
  <parameter name="InputHits" type="string" lcioInType="TrackerHit">TPCHits </parameter>
</processor>

 <processor name="MyXYZDistributionTracksProcessor" type="XYZDistributionTracksProcessor">
 <!--XYZDistributionTracksProcessor: Fill x, y, and z distribution of hits in tracks into AIDA histgram-->
  <!--Maximal value in x histogram (default:  15. mm)-->
  <parameter name="HistogramMaxValueX" type="float">15 </parameter>
  <!--Maximal value in y histogram (default:  15. mm)-->
  <parameter name="HistogramMaxValueY" type="float">15 </parameter>
  <!--Maximal value in z histogram (default:  260.0 mm)-->
  <parameter name="HistogramMaxValueZ" type="float">260 </parameter>
  <!--Minimum value in x histogram (default: 0. mm)-->
  <parameter name="HistogramMinValueX" type="float">0 </parameter>
  <!--Minimum value in y histogram (default: 0. mm)-->
  <parameter name="HistogramMinValueY" type="float">0 </parameter>
  <!--Minimum value in z histogram (default: 0.0 mm)-->
  <parameter name="HistogramMinValueZ" type="float">0 </parameter>
  <!--Name of the input tracks collection-->
  <parameter name="InputTracks" type="string" lcioInType="Track">TPCTracks </parameter>
</processor>

 <processor name="MyYThresh" type="YThresh">
 <!--YThresh finds the crossover value of the yCut variable from NMin to NMin+1 jets found using durhamycut-->
  <!--number of iterations-->
  <parameter name="NIterations" type="int">20 </parameter>
  <!--min number of jets, ie. NMin=2 will give y23 variable-->
  <parameter name="NMin" type="int">2 </parameter>
  <!--min num particles for ythresh calculation-->
  <parameter name="NMinParticles" type="int">3 </parameter>
  <!--toggle print text output-->
  <parameter name="PrintOutput" type="int">0 </parameter>
  <!--Name of the input ReconstructedParticle collection-->
  <parameter name="RecoParticleCollection" type="string" lcioInType="ReconstructedParticle">RecoParticles </parameter>
  <!--starting value for yCut-->
  <parameter name="YStart" type="float">0.1 </parameter>
</processor>

 <processor name="MyZVTOP_ZVKINProcessor" type="ZVTOP_ZVKINProcessor">
 <!--ZVTOP_ZVKIN - Kinematic Vertex Reconstruction Algorithm-->
  <!--Name of the ReconstructedParticle collection that holds RPs representing output decay chains-->
  <parameter name="DecayChainCollectionName" type="string" lcioOutType="ReconstructedParticle">ZVKINDecayChains </parameter>
  <!--Name of the ReconstructedParticle collection that represents tracks in output decay chains-->
  <parameter name="DecayChainRPTracksCollectionName" type="string" lcioOutType="ReconstructedParticle">ZVKINDecayChainRPTracks </parameter>
  <!--Name of the Vertex collection that contains the primary vertex (Optional)-->
  <parameter name="IPVertexCollection" type="string" lcioInType="Vertex">IPVertex </parameter>
  <!--Width in cm of the ghost inital ghosttrack, also the smallest width it is allowed to have-->
  <!--parameter name="InitialGhostWidth" type="double">0.025 </parameter-->
  <!--Name of the ReconstructedParticle collection that represents jets-->
  <parameter name="JetRPCollection" type="string" lcioInType="ReconstructedParticle">Jets </parameter>
  <!--If false then the primary vertex from VertexCollection is used-->
  <parameter name="ManualIPVertex" type="bool">true </parameter>
  <!--Manually set error matrix of the primary vertex (cm) (lower symmetric)-->
  <!--parameter name="ManualIPVertexError" type="FloatVec">2.5e-05 0 2.5e-05 0 0 0.0004  </parameter-->
  <!--Manually set position of the primary vertex (cm) - non origin IP not yet fully supported-->
  <!--parameter name="ManualIPVertexPosition" type="FloatVec">0 0 0  </parameter-->
  <!--The ghost track is widened until all forward jet tracks have a chi squared lower than this value-->
  <!--parameter name="MaxChi2Allowed" type="double">1 </parameter-->
  <!--If a vertex candidate has a probability below this it will not be considered - lower value results in more merging and lower vertex multiplicity-->
  <!--parameter name="MinimumProbability" type="double">0.01 </parameter-->
  <!--If true the chi squared contributions of tracks to vertices is written to LCIO-->
  <!--parameter name="OutputTrackChi2" type="bool">false </parameter-->
  <!--Name of the Vertex collection that contains found vertices-->
  <parameter name="VertexCollection" type="string" lcioOutType="Vertex">ZVKINVertices </parameter>
</processor>

 <processor name="MyZVTOP_ZVRESProcessor" type="ZVTOP_ZVRESProcessor">
 <!--ZVTOP_ZVRES - Vertex Reconstruction Algorithm-->
  <!--Name of the ReconstructedParticle collection that holds RPs representing output decay chains-->
  <parameter name="DecayChainCollectionName" type="string" lcioOutType="ReconstructedParticle">ZVRESDecayChains </parameter>
  <!--Name of the ReconstructedParticle collection that represents tracks in output decay chains-->
  <parameter name="DecayChainRPTracksCollectionName" type="string" lcioOutType="ReconstructedParticle">ZVRESDecayChainRPTracks </parameter>
  <!--Name of the Vertex collection that contains the primary vertex (Optional)-->
  <parameter name="IPVertexCollection" type="string" lcioInType="Vertex">IPVertex </parameter>
  <!--Weight of the IP in the Vertex Function-->
  <!--parameter name="IPWeighting" type="double">1 </parameter-->
  <!--Name of the ReconstructedParticle collection that represents jets-->
  <parameter name="JetRPCollection" type="string" lcioInType="ReconstructedParticle">Jets </parameter>
  <!--Scaling factor for Weight of the jet direction in the Vertex Function-->
  <!--parameter name="JetWeightingEnergyScaling" type="double">0.125 </parameter-->
  <!--If false then the primary vertex from VertexCollection is used-->
  <parameter name="ManualIPVertex" type="bool">true </parameter>
  <!--Manually set error matrix of the primary vertex (cm) (lower symmetric)-->
  <!--parameter name="ManualIPVertexError" type="FloatVec">2.5e-05 0 2.5e-05 0 0 0.0004  </parameter-->
  <!--Manually set position of the primary vertex (cm)-->
  <!--parameter name="ManualIPVertexPosition" type="FloatVec">0 0 0  </parameter-->
  <!--If true the chi squared contributions of tracks to vertices is written to LCIO-->
  <!--parameter name="OutputTrackChi2" type="bool">false </parameter-->
  <!--Cut to determine if two vertices are resolved-->
  <!--parameter name="ResolverCut" type="double">0.6 </parameter-->
  <!--Chi Squared cut for final trimming of tracks from vertices-->
  <!--parameter name="TrackTrimCut" type="double">10 </parameter-->
  <!--Chi Squared cut for making initial track pairs - chi squared of either track NOT sum-->
  <!--parameter name="TwoTrackCut" type="double">10 </parameter-->
  <!--Name of the Vertex collection that contains found vertices-->
  <parameter name="VertexCollection" type="string" lcioOutType="Vertex">ZVRESVertices </parameter>
</processor>


</marlin>
